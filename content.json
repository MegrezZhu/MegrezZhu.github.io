{"meta":{"title":"Megrez","subtitle":"Everything is for DOPAMINE","description":"Everything is for DOPAMINE","author":"Zhu Chu","url":"http://yoursite.com"},"pages":[{"title":"tags","date":"2017-09-07T05:12:01.000Z","updated":"2017-09-07T05:13:11.482Z","comments":true,"path":"tags/index.html","permalink":"http://yoursite.com/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"axios入坑指北","slug":"axios入坑指北","date":"2018-04-08T02:07:07.000Z","updated":"2018-04-08T05:07:34.414Z","comments":true,"path":"2018/04/08/axios入坑指北/","link":"","permalink":"http://yoursite.com/2018/04/08/axios入坑指北/","excerpt":"axios是一个基于JavaScript的HTTP请求模块，为JavaScript的两个主要环境（Node.js与Browser）提供了一致的HTTP接口。 由于axios的readme里面已经有十分详尽的API文档以及设置项说明，因此这篇博客将主要介绍一些文档里没有的东西（a.k.a 坑），使用部分将简单带过。 Note：本篇博客基于axios目前的最新版本0.18.0，由于axios近期可能会有大的更新(see this issue)，届时本篇博客部分内容可能将过时。","text":"axios是一个基于JavaScript的HTTP请求模块，为JavaScript的两个主要环境（Node.js与Browser）提供了一致的HTTP接口。 由于axios的readme里面已经有十分详尽的API文档以及设置项说明，因此这篇博客将主要介绍一些文档里没有的东西（a.k.a 坑），使用部分将简单带过。 Note：本篇博客基于axios目前的最新版本0.18.0，由于axios近期可能会有大的更新(see this issue)，届时本篇博客部分内容可能将过时。 Features 以下来自readme： Make XMLHttpRequests from the browser Make http requests from node.js Supports the Promise API Intercept request and response Transform request and response data Cancel requests Automatic transforms for JSON data Client side support for protecting against XSRF 在一般的使用情景下，主要的痛点在于： Promise API 取消请求的能力（which is使用原生Promise比较难办的需求） 通过intercept扩展功能 基本使用 引入 对于Browser： 1&lt;script src=\"https://unpkg.com/axios/dist/axios.min.js\"&gt;&lt;/script&gt; 对于Node.js，以及使用了Webpack等构建工具的前端项目： 1import axios from 'axios'; // es module or: 1const axios = require('axios'); // Node.js / CommonJS 配置 axios有许多配置项，它们的默认值在这里可以察看。在需要对默认值进行修改的时候（比如修改请求的默认baseURL），通过： 1234const ax = require('axios').create(&#123; baseURL: 'http://my.custom-base-domain.com', timeout: 3000&#125;); 对默认配置进行覆盖。 而在请求的时候，可以通过提供配置项来对上面的设置进行再次覆盖： 1ax.get('https://www.google.com', &#123; timeout: 5000 &#125;); 总地来说，axios中的配置项的优先级为：请求中配置&gt;用户默认配置&gt;axios默认配置。 请求 由于axios提供了基于Promise的API，因此可以很优雅地写出链式的代码： 1234567891011axios .get('https://www.google.com') .then(res =&gt; &#123; console.log(res.data) &#125;) .catch(console.error);axios .post('/api/user', &#123; name: 'chu' &#125;) .then((&#123; status &#125;) =&gt; &#123; console.log(`regist done with status code $&#123;status&#125;.`); &#125;); 当然，一般更推荐Promise和Async/Await配合食用（需要注意执行环境的兼容性）： 123456789(async () =&gt; &#123; try &#123; const &#123; data &#125; = await axios.get('http://fake-domain/news-today'); console.log(data); &#125; catch (err) &#123; console.error('error!'); &#125;&#125;)() .catch(console.error); 入坑与爬坑 Note again: 这里讲的是0.18.0中的情况，在新的axios大版本将有可能： 修复这些问题 原生提供解决方案 Cookies 虽然说axios旨在为Node.js端与Browser端提供统一的HTTP API， 但在Cookie的支持上还是有一点不同。 在浏览器端，由于浏览器自带对Cookie的管理，因此只需要在axios的配置中加入withCredentials: true即可。 而在Node.js端，由于node环境原生并没有对cookie进行handle（而很神奇地，axios也并没有做处理），因此想要在node下获得和浏览器端一致的体验，需要引入下面两个额外的模块： axios-cookiejar-support tough-cookie 并进行如下的配置： 123456789101112131415const axios = require('axios').default;const axiosCookieJarSupport = require('axios-cookiejar-support').default;const tough = require('tough-cookie'); axiosCookieJarSupport(axios); const cookieJar = new tough.CookieJar(); axios.get('https://google.com', &#123; jar: cookieJar, // tough.CookieJar or boolean withCredentials: true // If true, send cookie stored in jar&#125;).then(() =&gt; &#123; console.log(cookieJar);&#125;); 注意，引入模块之后仍然需要withCredentials: true的配置项来使用cookies。 Proxy 这一项由于我不清楚是使用方式的原因还是axios本身的bug，因此只能提供一种workaround。如果是我自己使用方式不当导致的，请在评论区或者发邮件告诉我:) 由于一些不可名状的原因，在写需要进行HTTP请求的代码的时候（特别是各种爬虫），经常需要通过中间代理，而axios自身虽然在配置项中提供了proxy字段，但亲测它的可用性比较差（主要是无法通过http proxy访问https的链接），因此需要一些额外的工作。 需要用到的库：caw caw是一个用于提供http/https agent的库，具有相似功能的还有：tunnel, http-proxy(s)-agent等，但经测试似乎只有caw能与axios兼容:( 使用方式： 12345678910const ax = require('axios');const caw = require('caw');ax.get( 'https://google.com', &#123; httpAgent: caw('http://127.0.0.1:1080'), httpsAgent: caw('https://127.0.0.1:1080', &#123; protocol: &#125;) &#125;); Retry 这一点并不是axios的bug或者不足之处，只是我自己在写项目时候的一个痒点，在这里分享出来。 由于网络服务的不稳定性，在一些比较重要的、需要保证成功请求的情景下，需要通过多次请求来保证成功，于是经常会写出下面这样的代码： 12345678910async function getSomething (url) &#123; let maxRetry = 3; while (maxRetry--) &#123; try &#123; const &#123; data &#125; = await axios.get(url); return data; &#125; catch (err) &#123;&#125; &#125; throw new Error('failed too many times.');&#125; 当然，为了D.R.Y.，到处这样写当然是不优雅的，因此可以通过axios的interceptor来达成： 123456789101112131415161718axios.interceptors.response.use( res =&gt; res, err =&gt; &#123; if (err.message &amp;&amp; err.message.match(/timeout/)) &#123; // timeout case const config = err.config; if (config.method !== 'get') return Promise.reject(err); // only retry GET methods if (config._leftRetry) config._leftRetry--; else config._leftRetry = 3; // default retry times if (config._leftRetry) &#123; return axios(config); &#125; else &#123; return Promise.reject(err); &#125; &#125; return Promise.reject(err); &#125;); 当然上面代码还有许多修改的空间，比如可以根据具体需求修改重试的条件（在上面的代码中我只对超时的情景进行了重新请求），或者修改重试的method条件。 Note：重试时需要保证调用的API的幂等性Idempotency，否则重试可能会带来额外的副作用。 Timeout axios自身即对请求超时有支持（设置项timeout: 3000ms），但超时的计算仅限于从发出请求到服务端返回response header的时刻，也就是说从收到response header到完整接收response body的这段时间是没有计算在内的。 而在一些比较少见的情况下（特别是response body比较大，比如图片下载的情况），response body的接收速度会降为0，但由于连接仍未被断开，因此仍未算作请求失败——于是就出现了请求时间&gt;&gt;超时时限仍未结束的问题。 其实从严格意义上来讲，这并不是bug或者缺陷。不过有时候尽早结束没有速度的下载并重新开始一个新的请求比等待一个不定长的时间来得更加行之有效，于是可以使用Interceptor结合cancelToken对下载超时的情况增加timeout限制。 12345678910111213141516axios.interceptors.request.use( config =&gt; &#123; const cancelSource = CancelToken.source(); const token = cancelSource.token; setTimeout(() =&gt; &#123; cancelSource.cancel('custom timeout.'); &#125;, TIMEOUT); return &#123; ...config, cancelToken: cancelSource.token &#125;; &#125;, Promise.reject); 当然，这段代码只是一个不成熟的草稿，有一些额外的问题（比如会覆盖原请求的cancelToken）。 Incomplete Body 与上一个类似，在response body较大、网络状态不佳的时候有可能出现。在传输过程中连接被中断，axios会认为是连接正常终止： incomplete file 对于这个问题，没有什么很优雅的解决方法，可以通过设置response interceptor来加一层body size的判断。 最后 其实相比于另外一个HTTP库request，axios还是有比较多的坑的。但毕竟头比较铁，尝试着找到了一些workaround配合上也能用。 （毕竟相比request，个人觉得axios的名字更酷炫一点哈哈哈哈）","categories":[],"tags":[{"name":"JavaScirpt","slug":"JavaScirpt","permalink":"http://yoursite.com/tags/JavaScirpt/"},{"name":"Node.js","slug":"Node-js","permalink":"http://yoursite.com/tags/Node-js/"}]},{"title":"对STINGY SAT问题属于NPC的简单证明","slug":"STINGY-SAT问题的简单证明","date":"2018-01-13T13:26:15.000Z","updated":"2018-01-21T13:42:12.923Z","comments":true,"path":"2018/01/13/STINGY-SAT问题的简单证明/","link":"","permalink":"http://yoursite.com/2018/01/13/STINGY-SAT问题的简单证明/","excerpt":"STINGY SAT is the following problem: given a set of clauses (each a disjunction of literals) and an integer k, find a satisfying assignment in which at most k variables are true, if such an assignment exists. 简单来说，STINGY SAT（该翻译成贪婪SAT？）问题是SAT（Boolean Satisfiability Problem）的扩展，增加了一个限制：解中True的数量不能超过k个。","text":"STINGY SAT is the following problem: given a set of clauses (each a disjunction of literals) and an integer k, find a satisfying assignment in which at most k variables are true, if such an assignment exists. 简单来说，STINGY SAT（该翻译成贪婪SAT？）问题是SAT（Boolean Satisfiability Problem）的扩展，增加了一个限制：解中True的数量不能超过k个。 根据证明NPC（NP-Complete）问题的基本做法，主要需要找出从一个NPC问题规约到STINGY SAT问题的方法，在这里我直接选择了SAT进行规约。 规约的方式是显而易见的：对于有\\(n\\)个变量的SAT的问题，其解中True的个数必然不超过\\(n\\)个，因此一个有\\(n\\)个变量的SAT可以规约成一个\\(k=n\\)的STINGY SAT问题。 进行规约之后，根据如下证明： 若STINGY SAT有多项式解法，那么就可以用这个解法同样在多项式时间内解决SAT问题，于是SAT不是NPC。 于是与SAT是NPC的前提矛盾。 因此STINGY SAT也是NPC。 证毕。","categories":[],"tags":[{"name":"NP","slug":"NP","permalink":"http://yoursite.com/tags/NP/"}]},{"title":"LeetCode 刷题记录 （二十）","slug":"LeetCode-刷题记录-（二十）","date":"2018-01-10T11:36:40.000Z","updated":"2018-01-21T12:51:26.371Z","comments":true,"path":"2018/01/10/LeetCode-刷题记录-（二十）/","link":"","permalink":"http://yoursite.com/2018/01/10/LeetCode-刷题记录-（二十）/","excerpt":"Find Largest Value in Each Tree Row https://leetcode.com/problems/find-largest-value-in-each-tree-row/description/ 题意 给定一个二叉树，对二叉树的每一行（深度相同的所有节点视为在同一行），找出行内的最大元素。 思路 BFS。","text":"Find Largest Value in Each Tree Row https://leetcode.com/problems/find-largest-value-in-each-tree-row/description/ 题意 给定一个二叉树，对二叉树的每一行（深度相同的所有节点视为在同一行），找出行内的最大元素。 思路 BFS。 代码 1234567891011121314151617181920212223class Solution &#123;public: vector&lt;int&gt; largestValues(TreeNode* root) &#123; if (!root) return &#123;&#125;; vector&lt;int&gt; res; list&lt;TreeNode*&gt; parent = &#123; root &#125;; while (!parent.empty()) &#123; list&lt;TreeNode*&gt; son; int _max = -2147483648; while (!parent.empty()) &#123; auto p = parent.front(); parent.pop_front(); if (p-&gt;left) son.push_back(p-&gt;left); if (p-&gt;right) son.push_back(p-&gt;right); _max = max(_max, p-&gt;val); &#125; res.push_back(_max); parent = move(son); &#125; return res; &#125;&#125;; Partition Equal Subset Sum https://leetcode.com/problems/partition-equal-subset-sum/description/ 题意 对于一个正整数数组\\(A\\)，判断这个数组是否可以被划分成两个和相等的子数组（不需要连续）。 思路 经典背包题。考虑到两个子数组的元素和相等，显然对于每个子数组，其和为\\(\\frac{\\sum_{i}A_i}{2}\\)。于是可以转换一个等价的0-1背包问题：背包容量为\\(\\frac{\\sum_{i}A_i}{2}\\)，是否能装满？ 代码 12345678910111213141516class Solution &#123;public: bool canPartition(vector&lt;int&gt;&amp; nums) &#123; int sum = 0; for (int x : nums) sum += x; if (sum % 2) return false; vector&lt;bool&gt; f(sum / 2 + 1); f[0] = true; for (int i = 1; i &lt; nums.size(); i++) &#123; for (int j = sum / 2; j &gt;= 0; j--) &#123; if (j - nums[i] &gt;= 0) f[j] = f[j] || f[j - nums[i]]; &#125; &#125; return f[sum / 2]; &#125;&#125;;","categories":[],"tags":[{"name":"LeetCode","slug":"LeetCode","permalink":"http://yoursite.com/tags/LeetCode/"}]},{"title":"LeetCode 刷题记录 （十九）","slug":"LeetCode-刷题记录-（十九）","date":"2018-01-05T15:29:25.000Z","updated":"2018-01-21T12:36:54.186Z","comments":true,"path":"2018/01/05/LeetCode-刷题记录-（十九）/","link":"","permalink":"http://yoursite.com/2018/01/05/LeetCode-刷题记录-（十九）/","excerpt":"Number of Atoms https://leetcode.com/problems/number-of-atoms/description/ 题意 给定一个字符串形式的化学式（如\\(H_2O\\)），计算里面各种原子的个数，并按元素符号升序输出。","text":"Number of Atoms https://leetcode.com/problems/number-of-atoms/description/ 题意 给定一个字符串形式的化学式（如\\(H_2O\\)），计算里面各种原子的个数，并按元素符号升序输出。 思路 题意很简单，但因为化学式中也有括号嵌套（如\\(Mg(OH)_2\\)），因此不能直接无脑扫一遍得结果，需要用个栈来处理括号。 其余都是一些细节上的问题，具体实现见下面代码。 代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778class Solution &#123; typedef map&lt;string, int&gt; Data; enum STATE &#123; &#125;; void combine(Data &amp;a, const Data &amp;b, int multiplier = 1) &#123; for (const auto &amp;p : b) &#123; auto it = a.find(p.first); if (it == a.end()) it = a.insert(make_pair(p.first, 0)).first; it-&gt;second += p.second * multiplier; &#125; &#125; void fold(stack&lt;Data&gt; &amp;stk, int multiplier = 1) &#123; auto top = move(stk.top()); stk.pop(); combine(stk.top(), top, multiplier); &#125;public: string countOfAtoms(string formula) &#123; stack&lt;Data&gt; stk; string buf; stk.push(Data()); for (size_t pos = 0; pos &lt; formula.length(); pos++) &#123; char ch = formula[pos], peek = pos + 1 != formula.length() ? formula[pos + 1] : '\\0'; if (ch == '(') &#123; stk.push(Data()); continue; &#125; if (ch == ')') &#123;&#125; // nothing if (isdigit(ch)) &#123; buf += ch; if (!isdigit(peek)) &#123; fold(stk, stoi(buf)); buf.clear(); &#125; continue; &#125; if (isupper(ch)) &#123; buf = ch; if (!islower(peek) &amp;&amp; !isdigit(peek)) &#123; stk.push(Data(&#123; &#123;buf, 1&#125; &#125;)); fold(stk); buf.clear(); &#125; else if (isdigit(peek)) &#123; stk.push(Data(&#123; &#123; buf, 1 &#125; &#125;)); buf.clear(); &#125; continue; &#125; if (islower(ch)) &#123; buf += ch; if (!islower(peek) &amp;&amp; !isdigit(peek)) &#123; stk.push(Data(&#123; &#123; buf, 1 &#125; &#125;)); fold(stk); buf.clear(); &#125; else &#123; stk.push(Data(&#123; &#123; buf, 1 &#125; &#125;)); buf.clear(); &#125; continue; &#125; &#125; string res; for (auto &amp;p : stk.top()) &#123; res += p.first; if (p.second &gt; 1) res += to_string(p.second); &#125; return res; &#125;&#125;;","categories":[],"tags":[{"name":"LeetCode","slug":"LeetCode","permalink":"http://yoursite.com/tags/LeetCode/"}]},{"title":"LeetCode 刷题记录 （十八）","slug":"LeetCode-刷题记录-（十八）","date":"2018-01-02T02:14:17.000Z","updated":"2018-01-21T12:36:55.844Z","comments":true,"path":"2018/01/02/LeetCode-刷题记录-（十八）/","link":"","permalink":"http://yoursite.com/2018/01/02/LeetCode-刷题记录-（十八）/","excerpt":"Decode Ways II https://leetcode.com/problems/decode-ways-ii/description/ 题意 一个只含有大写英文字母的字符串，根据'A' -&gt; 1; 'B' -&gt; 2; ...'Z' -&gt; 26的规则被编码为只含有数字的字符串（如ABC被编码为123）。 现在给定给一个只含有数字和*（通配符，可以是任何字符）的字符串\\(T\\)，求有多少个不同的原字符串可以编码成\\(T\\)。","text":"Decode Ways II https://leetcode.com/problems/decode-ways-ii/description/ 题意 一个只含有大写英文字母的字符串，根据'A' -&gt; 1; 'B' -&gt; 2; ...'Z' -&gt; 26的规则被编码为只含有数字的字符串（如ABC被编码为123）。 现在给定给一个只含有数字和*（通配符，可以是任何字符）的字符串\\(T\\)，求有多少个不同的原字符串可以编码成\\(T\\)。 思路 动态规划。\\(F_{i}\\)表示\\(T_{0:i}\\)可以由多少个不同的原字符串编码而成。于是有下面的状态转移方程： \\[ F_{i}=F_{i-1}G(T_i)+F_{i-2}G(T_{i-1:i}) \\] 其中\\(G(s)\\)表示数字字符串\\(s\\)可以解码为多少种原字符串。 比如：\\(G(&#39;2&#39;)=|\\{&#39;B&#39;\\}|=1\\)，\\(G(&#39;11&#39;)=|\\{‘AA&#39;,&#39;K&#39;\\}|=2\\)，\\(G(&#39;*&#39;)=|\\{&#39;A&#39;, ...,&#39;Z&#39;\\}|=26\\)。 代码 1234567891011121314151617181920212223242526272829303132333435363738class Solution &#123; inline bool isNonZero(char a) &#123; return a &gt; '0' &amp;&amp; a &lt;= '9'; &#125; inline bool isNum(char a) &#123; return a &gt;= '0' &amp;&amp; a &lt;= '9'; &#125;public: int numDecodings(string s) &#123; constexpr long long MOD = 1e9 + 7; if (!s.length()) return 0; vector&lt;long long&gt; f(s.length() + 1); f[0] = 1; for (int i = 0; i &lt; s.length(); i++) &#123; if (s[i] == '*') f[i + 1] = (f[i] * 9) % MOD; else if (isNonZero(s[i])) f[i + 1] = f[i]; else f[i] = 0; if (i == 0) continue; if (isNonZero(s[i - 1])) &#123; if (isNum(s[i])) &#123; if (s[i - 1] * 10 + s[i] - 11 * '0' &lt;= 26) f[i + 1] = (f[i + 1] + f[i - 1]) % MOD; &#125; else if (s[i] == '*') &#123; int fac = 0; if (s[i - 1] == '1') fac = 9; else if (s[i - 1] == '2') fac = 6; f[i + 1] = (f[i + 1] + fac * f[i - 1]) % MOD; &#125; &#125; else if (s[i - 1] == '*') &#123; if (s[i] == '*') f[i + 1] = (f[i + 1] + f[i - 1] * 15) % MOD; // 11~19, 21~26 else if (isNum(s[i])) &#123; f[i + 1] = (f[i + 1] + (s[i] &lt;= '6' ? 2 : 1) * f[i - 1]) % MOD; &#125; &#125; &#125; return f[s.length()]; &#125;&#125;;","categories":[],"tags":[{"name":"LeetCode","slug":"LeetCode","permalink":"http://yoursite.com/tags/LeetCode/"}]},{"title":"LeetCode 刷题记录 （十七）","slug":"LeetCode-刷题记录-（十七）","date":"2017-12-31T04:01:23.000Z","updated":"2018-01-21T12:51:28.431Z","comments":true,"path":"2017/12/31/LeetCode-刷题记录-（十七）/","link":"","permalink":"http://yoursite.com/2017/12/31/LeetCode-刷题记录-（十七）/","excerpt":"Split Array Largest Sum https://leetcode.com/problems/split-array-largest-sum/description/ 题意 给定一个非负整数数组\\(A\\)，将其分割成\\(m\\)个非空连续子数组，要求使每个子数组中所有元素的和的最大值最小，并求这个最小的最大值。","text":"Split Array Largest Sum https://leetcode.com/problems/split-array-largest-sum/description/ 题意 给定一个非负整数数组\\(A\\)，将其分割成\\(m\\)个非空连续子数组，要求使每个子数组中所有元素的和的最大值最小，并求这个最小的最大值。 思路 类似于“最大值最小”这样的问题，一般要么是动态规划、要么是二分。 这道题因为满足二分的要求，因此可以二分最大值\\(M\\)。对于这个最大值，检查是否可以划分成m个非空数组满足这个最大值，若不满足，则可以确定\\(M\\)过大；否则\\(M\\)是一个可行的解，于是往更小的方向进行二分。 检查的方法：\\(O(|A|)\\)扫描一遍，在满足和不大于\\(M\\)的前提下将尽可能多的元素分到一组（这样能保证尽可能少的分组数量），如果这样得出的最少分组数依然大于\\(m\\)的话，就可以确定当前选择的\\(M\\)过小。 整体复杂度：\\(O(|A|log_2{(\\sum_{i}A_i)})\\)。 代码 123456789101112131415161718192021222324252627282930313233class Solution &#123; typedef long long ll; bool check(const vector&lt;int&gt; &amp;nums, int m, int limit) &#123; for (int i = 0, sum = 0; i &lt; nums.size(); i++) &#123; if (sum + nums[i] &lt;= limit) sum += nums[i]; else &#123; m--; if (m == 0) return false; sum = nums[i]; &#125; &#125; return true; &#125;public: int splitArray(vector&lt;int&gt;&amp; nums, int m) &#123; int n = nums.size(); int l = 0, r = 0; for (int i : nums) &#123; l = max(l, i); r += i; &#125; int ans = 2147483647; while (l &lt;= r) &#123; int mid = (ll(l) + ll(r)) / 2; if (check(nums, m, mid)) &#123; r = mid - 1; ans = min(ans, mid); &#125; else l = mid + 1; &#125; return ans; &#125;&#125;;","categories":[],"tags":[{"name":"LeetCode","slug":"LeetCode","permalink":"http://yoursite.com/tags/LeetCode/"}]},{"title":"LeetCode 刷题记录 （十六）","slug":"LeetCode-刷题记录-（十六）","date":"2017-12-29T12:11:06.000Z","updated":"2018-01-21T12:08:16.974Z","comments":true,"path":"2017/12/29/LeetCode-刷题记录-（十六）/","link":"","permalink":"http://yoursite.com/2017/12/29/LeetCode-刷题记录-（十六）/","excerpt":"Distinct Subsequences https://leetcode.com/problems/distinct-subsequences/description/ 题意 对于给定的两个字符串\\(S\\)和\\(T\\)，求\\(S\\)有多少个子序列等于\\(T\\)。","text":"Distinct Subsequences https://leetcode.com/problems/distinct-subsequences/description/ 题意 对于给定的两个字符串\\(S\\)和\\(T\\)，求\\(S\\)有多少个子序列等于\\(T\\)。 思路 动态规划。\\(F_{i,j}\\)表示\\(S_{0:i}\\)（表示\\(S\\)下标从\\(0\\)到\\(i\\)的前缀）中等于\\(T_{0..j}\\)的子序列个数，于是有转移方程： \\[ F_{i,j}=F_{i-1,j}+F_{i-1,j-1}\\times(S_{i}=T_{j}) \\] 再应用类似01背包问题中的优化，可以将状态从二维降为一维。具体实现见下面代码。 最终时间复杂度为\\(O(|S||T|)\\)，空间复杂度为\\(O(|T|)\\) 代码 123456789101112131415class Solution &#123;public: int numDistinct(string s, string t) &#123; vector&lt;int&gt; f; f.resize(t.length() + 1, 0); f[0] = 1; // dp[0][0] = 1 for (int i = 1; i &lt;= s.length(); i++) &#123; for (int j = t.length(); j &gt; 0; j--) &#123; if (i &lt; j) f[j] = 0; else f[j] = f[j] + (s[i - 1] == t[j - 1] ? f[j - 1] : 0); &#125; &#125; return f[t.size()]; &#125;&#125;;","categories":[],"tags":[{"name":"LeetCode","slug":"LeetCode","permalink":"http://yoursite.com/tags/LeetCode/"}]},{"title":"LeetCode 刷题记录（十五）","slug":"LeetCode-刷题记录-（十五）","date":"2017-12-27T07:32:25.000Z","updated":"2018-01-21T12:03:36.690Z","comments":true,"path":"2017/12/27/LeetCode-刷题记录-（十五）/","link":"","permalink":"http://yoursite.com/2017/12/27/LeetCode-刷题记录-（十五）/","excerpt":"Smallest Good Base https://leetcode.com/problems/smallest-good-base/description/ 题意 对于一个整数\\(n\\)，它的一个Good Base（好基？）被定义为一个这样的一个整数\\(k\\)，满足： \\(k\\ge 2\\) 在\\(k\\)进制下，\\(n\\)的每一位都是\\(1\\) 于是问题是，给定一个字符串表示\\(n\\)，\\(n\\in[3,10^{18}]\\)，求它的最小的Good Base。","text":"Smallest Good Base https://leetcode.com/problems/smallest-good-base/description/ 题意 对于一个整数\\(n\\)，它的一个Good Base（好基？）被定义为一个这样的一个整数\\(k\\)，满足： \\(k\\ge 2\\) 在\\(k\\)进制下，\\(n\\)的每一位都是\\(1\\) 于是问题是，给定一个字符串表示\\(n\\)，\\(n\\in[3,10^{18}]\\)，求它的最小的Good Base。 思路 考虑\\(n\\)在\\(k\\)进制下的表示，因为全都由\\(1\\)组成，因此如果我们要求\\(n\\)在\\(k\\)进制下的\\(1\\)的位数是\\(len\\)的话，问题就变成寻找一个最小的\\(k\\)满足\\((A_{len})_{k}=(n)_{10}\\)，其中\\(A_{len}\\)是一个由\\(len\\)个\\(1\\)组成的数字串。 很显然在\\(len\\)不变的前提下，等式左边是关于\\(k\\)单调上升的，于是就可以通过二分来求解是否存在满足条件的k。 同时因为\\(n\\in[3,10^{18}]\\)，因此显然在\\(k\\)进制下，\\(n\\)的位数（即\\(len\\)）不可能超过\\(\\lceil log_210^{18}\\rceil\\)（代码中直接用63作为上限），因此直接枚举\\(len\\)计算在不同\\(len\\)$下的答案取最小即可。 给定一个字符串表示\\(n\\)，\\(n\\in[3,10^{18}]\\)，求它的最小的Good Base 代码 123456789101112131415161718192021222324252627282930313233343536373839class Solution &#123; typedef unsigned long long ull; /* 0 for yes, 1 for greater, -1 for smaller @pragma len: number of 1s */ int check(ull base, int len, ull target) &#123; ull res = 1; while (--len) &#123; if (ull(res * base) / base != res) return 1; // overflow res = res * base + 1; &#125; if (res &gt; target) return 1; if (res &lt; target) return -1; return 0; &#125;public: string smallestGoodBase(string n) &#123; ull target = stoull(n); ull ans = -1; // indicate max for (int len = 1; len &lt;= 63; len++) &#123; ull l = 2, r = target - 1; while (l &lt;= r) &#123; ull m = (l + r) / 2; int res = check(m, len, target); if (res == 0) &#123; ans = min(ans, m); break; &#125; if (res == -1) l = m + 1; else r = m - 1; &#125; &#125; return to_string(ans); &#125;&#125;;","categories":[],"tags":[{"name":"LeetCode","slug":"LeetCode","permalink":"http://yoursite.com/tags/LeetCode/"}]},{"title":"LeetCode 刷题记录（十四）","slug":"LeetCode-刷题记录-（十四）","date":"2017-12-24T04:41:05.000Z","updated":"2018-01-21T11:45:32.544Z","comments":true,"path":"2017/12/24/LeetCode-刷题记录-（十四）/","link":"","permalink":"http://yoursite.com/2017/12/24/LeetCode-刷题记录-（十四）/","excerpt":"Find Median from Data Stream https://leetcode.com/problems/find-median-from-data-stream/description/ 题意 要求实现一个容器类，能够： 将一个元素加入容器中 计算当前容器中所有元素的中位数","text":"Find Median from Data Stream https://leetcode.com/problems/find-median-from-data-stream/description/ 题意 要求实现一个容器类，能够： 将一个元素加入容器中 计算当前容器中所有元素的中位数 思路 维护两个堆，大根堆\\(H_1\\)和小根堆\\(H_2\\)，\\(H_1\\)里面是当前容器中最小的\\(\\lfloor\\frac{N+1}{2}\\rfloor\\)个元素，相应的\\(H_2\\)里面是当前容器中最大的\\(N-\\lfloor\\frac{N+1}{2}\\rfloor\\)个元素。在有新元素加入时处理一下新元素和两个堆的根元素之间的移动关系即可，具体处理逻辑见下面代码。 在\\(N\\)为奇数时，中位数就是\\(H_1\\)的根；否则中位数是两个堆的根的均值。 时间复杂度：添加元素\\(\\mathcal{O}(\\log N)\\)，计算当前中位数\\(\\mathcal{O}(1)\\)。 代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748class MedianFinder &#123; vector&lt;int&gt; left, right; int size;public: /** initialize your data structure here. */ MedianFinder() &#123; size = 0; &#125; void addNum(int num) &#123; size++; int leftCap = (size + 1) / 2, rightCap = size - leftCap; if (left.size() &lt; leftCap) &#123; int toLeft; if (right.size() == 0 || num &lt;= right.front()) &#123; toLeft = num; &#125; else &#123; toLeft = right.front(); pop_heap(right.begin(), right.end(), greater&lt;int&gt;()); right.pop_back(); right.push_back(num); push_heap(right.begin(), right.end(), greater&lt;int&gt;()); &#125; left.push_back(toLeft); push_heap(left.begin(), left.end()); &#125; else &#123; int toRight; if (left.size() == 0 || num &gt;= left.front()) &#123; toRight = num; &#125; else &#123; toRight = left.front(); pop_heap(left.begin(), left.end()); left.pop_back(); left.push_back(num); push_heap(left.begin(), left.end()); &#125; right.push_back(toRight); push_heap(right.begin(), right.end(), greater&lt;int&gt;()); &#125; &#125; double findMedian() const &#123; if (size % 2) return left.front(); else return (left.front() + right.front()) / 2.0; &#125;&#125;;","categories":[],"tags":[{"name":"LeetCode","slug":"LeetCode","permalink":"http://yoursite.com/tags/LeetCode/"}]},{"title":"LeetCode 刷题记录 （十三）","slug":"LeetCode-刷题记录-（十三）","date":"2017-12-13T06:25:16.000Z","updated":"2018-01-21T11:43:07.071Z","comments":true,"path":"2017/12/13/LeetCode-刷题记录-（十三）/","link":"","permalink":"http://yoursite.com/2017/12/13/LeetCode-刷题记录-（十三）/","excerpt":"Longest Increasing Path in a Matrix https://leetcode.com/problems/longest-increasing-path-in-a-matrix/description/ 题意 给定一个\\(n\\times m\\)的整数矩阵\\(A\\)，找出里面最长的上升路径。（只能走上下左右四个方向）","text":"Longest Increasing Path in a Matrix https://leetcode.com/problems/longest-increasing-path-in-a-matrix/description/ 题意 给定一个\\(n\\times m\\)的整数矩阵\\(A\\)，找出里面最长的上升路径。（只能走上下左右四个方向） 思路 大体上还是与一维数组中的最长上升子序列相似，又因为是上升路径而不是不下降路径因此这个路径是不可能有环的。于是以\\(F_{i,j}\\)表示以\\((i,j)\\)为终点的最长上升路径的长度，\\(D_4(i,j)\\)表示点\\((i,j)\\)的4-邻域，于是有如下转移公式： \\[ F_{i,j}=max(\\{0\\}\\cup\\{F_{i&#39;,j&#39;}|(i&#39;,j&#39;)\\in D(i,j)\\land A_{i,j}&gt;A_{i&#39;,j&#39;}\\})+1 \\] 本题与一维数组的最长上升子序列计算的一个重要区别在于：一个路径并不是简单地“从左到右”的。 注意到上面的状态转移公式中，对于矩阵中的一个坐标\\((i,j)\\)，为了计算\\(F_{i,j}\\)，需要所有满足\\((i&#39;,j&#39;)\\in D(i,j)\\land A_{i,j}&gt;A_{i&#39;,j&#39;}\\)的点（与\\((i,j)\\)相邻且更小的点）的\\(F\\)计算出来。于是就涉及到一个计算顺序的问题：我们需要按照\\(A_{i,j}\\)升序顺序计算\\(F_{i,j}\\)，而不是简单的（如一维数组问题中的）坐标顺序。 解决方案 首先当然可以\\(O((mn)log_2(mn))\\)做一次排序后按照排序结果的顺序进行计算，但计算每个\\(F_{i,j}\\)只需要\\(O(1)\\)的复杂度，因此排序的速度已经成为整体复杂度的瓶颈。 于是可以采用类似记忆化搜索的递归过程，记录每个\\(F_{i,j}\\)是否已经计算，而当计算\\(F_{i,j}\\)依赖的\\(F_{i&#39;,j&#39;}\\)的结果并未被计算时进行递归计算、否则直接使用保存的值。这样整体复杂度降为了\\(O(mn)\\)。 代码 12345678910111213141516171819202122232425262728293031323334class Solution &#123; static int dx[4]; static int dy[4]; int dp(const vector&lt;vector&lt;int&gt;&gt;&amp; matrix, vector&lt;vector&lt;int&gt;&gt;&amp; result, int x, int y) &#123; if (result[x][y] &gt; 0) return result[x][y]; int n = matrix.size(), m = matrix.front().size(); result[x][y] = 1; for (int dir = 0; dir &lt; 4; dir++) &#123; int tx = x + dx[dir], ty = y + dy[dir]; if (tx &lt; 0 || tx &gt;= n || ty &lt; 0 || ty &gt;= m || matrix[tx][ty] &lt;= matrix[x][y]) continue; result[x][y] = max(result[x][y], dp(matrix, result, tx, ty) + 1); &#125; return result[x][y]; &#125;public: int longestIncreasingPath(vector&lt;vector&lt;int&gt;&gt;&amp; matrix) &#123; if (matrix.empty()) return 0; int n = matrix.size(), m = matrix.front().size(); vector&lt;vector&lt;int&gt;&gt; results(n, vector&lt;int&gt;(m, -1)); int ans = 0; for (int i = 0; i &lt; n; i++) &#123; for (int j = 0; j &lt; m; j++) ans = max(ans, dp(matrix, results, i, j)); &#125; return ans; &#125;&#125;;int Solution::dx[4] = &#123; 0, 1, 0, -1 &#125;;int Solution::dy[4] = &#123; 1, 0, -1, 0 &#125;;","categories":[],"tags":[{"name":"LeetCode","slug":"LeetCode","permalink":"http://yoursite.com/tags/LeetCode/"}]},{"title":"LeetCode 刷题记录 （十二）","slug":"LeetCode-刷题记录-（十二）","date":"2017-12-06T07:44:08.000Z","updated":"2017-12-07T01:45:56.808Z","comments":true,"path":"2017/12/06/LeetCode-刷题记录-（十二）/","link":"","permalink":"http://yoursite.com/2017/12/06/LeetCode-刷题记录-（十二）/","excerpt":"Russian Doll Envelopes https://leetcode.com/problems/russian-doll-envelopes/description/ 题意 有\\(n\\)个信封，每个信封都有自己的宽高，并且当一个信封\\(E_a\\)的宽高均严格大于另一个信封\\(E_b\\)的宽高时，可以将\\(E_b\\)套入\\(E_a\\)中。 现在给定若干个信封的宽高，问最多可以有几层的嵌套信封（原文是“俄罗斯套娃”）。","text":"Russian Doll Envelopes https://leetcode.com/problems/russian-doll-envelopes/description/ 题意 有\\(n\\)个信封，每个信封都有自己的宽高，并且当一个信封\\(E_a\\)的宽高均严格大于另一个信封\\(E_b\\)的宽高时，可以将\\(E_b\\)套入\\(E_a\\)中。 现在给定若干个信封的宽高，问最多可以有几层的嵌套信封（原文是“俄罗斯套娃”）。 思路 首先这道题的模型与最长上升子序列很像： 都有一个小于关系 都存在一个这样的性质：当\\(A\\)“大于”\\(B\\)时，\\(A\\)也“大于”\\(B\\)所嵌套的“信封” 于是就有一个Naive的做法： 把信封按宽度递增、再按高度递增进行排序 \\(F[E_i]\\)表示信封\\(i\\)为最外层信封时的最大嵌套层数，则有\\(F[E_i]=max\\{F[E_j]+1|E_i&gt;E_j\\}\\) 注意：就算排序之后，出现在后面的信封也不一定能嵌套前面的信封。 大致代码如下： 1234567for (int i = 1; i &lt; n; i++) &#123; for (int j = 0; j &lt; i; j++) &#123; if (E[i] &lt; E[j]) &#123; // need check dp[i] = max(dp[i], dp[j] + 1); &#125; &#125;&#125; 时间复杂度为\\(O(N^2)\\)，主要是没办法利用上经典的最长上升子序列的优化。 厉害一点的做法 考虑改变一种排序的方式：按宽度递增、在宽度相等时按高度递减排序，于是此时出现在\\((w,h)\\)前面的任意元素\\((w&#39;,h&#39;)\\)只有这两种情况之一： \\(w&#39;=w\\land h&#39;=h\\)，高度相等、因而不能嵌套 \\(w&#39;&lt;w&#39;\\)，是否可以嵌套取决于高度 于是可以按高度做一次最长上升子序列，加上如下优化： 维护\\(M_i\\)，表示所有满足长度为\\(i\\)的嵌套信封方案当中，最外层信封所需高度的最小值。 对于一个高度为\\(h\\)的信封，二分查找最大的\\(i\\)满足\\(M_i\\lt h\\)，然后更新\\(M_{i+1}\\) 代码 12345678910111213141516171819202122232425262728293031323334class Solution &#123; bool less(const pair&lt;int, int&gt;&amp; a, const pair&lt;int, int&gt;&amp; b) &#123; return a.first &lt; b.first &amp;&amp; a.second &lt; b.second; &#125;public: int maxEnvelopes(vector&lt;pair&lt;int, int&gt;&gt;&amp; envelopes) &#123; int n = envelopes.size(); if (!n) return 0; sort(envelopes.begin(), envelopes.end(), [](const pair&lt;int, int&gt;&amp; a, const pair&lt;int, int&gt;&amp; b) -&gt; bool &#123; if (a.first &gt; b.first) return false; if (a.first &lt; b.first) return true; if (a.second &gt; b.second) return true; if (a.second &lt; b.second) return false; return false; &#125;); int res = 1; vector&lt;int&gt; mx(n + 1, 2e9); mx[0] = 0; for (int i = 0; i &lt; n; i++) &#123; int l = 0, r = n; while (l &lt; r) &#123; int m = (l + r + 1) / 2; int mid = mx[m]; if (mid &lt; envelopes[i].second) l = m; else r = m - 1; &#125; mx[l + 1] = min(envelopes[i].second, mx[l + 1]); res = max(res, l + 1); &#125; return res; &#125;&#125;;","categories":[],"tags":[{"name":"LeetCode","slug":"LeetCode","permalink":"http://yoursite.com/tags/LeetCode/"}]},{"title":"LeetCode 刷题记录 （十一）","slug":"LeetCode-刷题记录-（十一）","date":"2017-11-15T07:25:37.000Z","updated":"2017-11-15T08:11:40.117Z","comments":true,"path":"2017/11/15/LeetCode-刷题记录-（十一）/","link":"","permalink":"http://yoursite.com/2017/11/15/LeetCode-刷题记录-（十一）/","excerpt":"Longest Valid Parentheses https://leetcode.com/problems/longest-valid-parentheses/description/ 题意 给出一串只包含(与)的括号字符串\\(S\\)，找出里面最长的合法括号子串的长度。","text":"Longest Valid Parentheses https://leetcode.com/problems/longest-valid-parentheses/description/ 题意 给出一串只包含(与)的括号字符串\\(S\\)，找出里面最长的合法括号子串的长度。 思路 回忆普通的括号匹配合法性检测，做法都是用一个栈结构维护目前待匹配的括号字符，然后每次取栈顶的字符与当前即将添加的字符比较，如果匹配则栈顶元素退栈，最后如果栈为空的话，则为合法的括号序列。 对比这道题，可以发现一个很有用的特性： 在上述括号匹配检测的过程中，在处理完第\\(i\\)个字符\\(S_i\\)后，若栈顶元素为\\(S_j\\)（显然\\(j&lt;i\\)），那么\\(S_{j+1}, S_{j+2}, ..., S_i\\)都不在栈中，也就是说这是一段合法的括号匹配序列。显然这也是以\\(S_i\\)为结尾的最长合法括号匹配序列。 那么这个问题其实就很简单了，只需要进行一次naive的括号匹配过程，并在每次处理完一个字符\\(S_i\\)后根据栈顶元素的在\\(S\\)中的位置得到以\\(S_i\\)结尾的最长合法括号匹配序列的长度并更新答案即可。 代码 1234567891011121314151617181920class Solution &#123; bool match(char a, char b) &#123; return a == '(' &amp;&amp; b == ')'; &#125;public: int longestValidParentheses(string s) &#123; stack&lt;pair&lt;char, int&gt;&gt; stk; int ans = 0; for (int i = 0; i &lt; s.length(); i++) &#123; char c = s[i]; if (stk.empty() || !match(stk.top().first, c)) stk.push(make_pair(c, i)); else &#123; stk.pop(); int left = stk.empty() ? -1 : stk.top().second; ans = max(ans, i - left); &#125; &#125; return ans; &#125;&#125;;","categories":[],"tags":[{"name":"LeetCode","slug":"LeetCode","permalink":"http://yoursite.com/tags/LeetCode/"}]},{"title":"LeetCode 刷题记录 （十）","slug":"LeetCode-刷题记录-（十）","date":"2017-11-12T06:46:51.000Z","updated":"2017-11-15T07:52:29.389Z","comments":true,"path":"2017/11/12/LeetCode-刷题记录-（十）/","link":"","permalink":"http://yoursite.com/2017/11/12/LeetCode-刷题记录-（十）/","excerpt":"Longest Consecutive Sequence https://leetcode.com/problems/longest-consecutive-sequence/description/ 题意 给定一个未排序的整数数组，找出（排序后）数组里面最长的连续元素序列（如[2, 3, 4, 5]）的长度。 思路 暴力的做法当然是\\(O(N\\log N)\\)排序之后\\(O(N)\\)扫一遍统计长度，这样总体复杂度是\\(O(N\\log N)\\)。 机智一些的做法则是\\(O(N)\\)的：","text":"Longest Consecutive Sequence https://leetcode.com/problems/longest-consecutive-sequence/description/ 题意 给定一个未排序的整数数组，找出（排序后）数组里面最长的连续元素序列（如[2, 3, 4, 5]）的长度。 思路 暴力的做法当然是\\(O(N\\log N)\\)排序之后\\(O(N)\\)扫一遍统计长度，这样总体复杂度是\\(O(N\\log N)\\)。 机智一些的做法则是\\(O(N)\\)的： 维护当前已经组成的所有连续序列，每次将一个数组中的元素加入已有序列并更新当前的所有连续序列。扫描一遍原数组需要\\(O(N)\\)，那么这个维护过程必须做到\\(O(1)\\)才能达到总体\\(O(N)\\)的复杂度，具体做法如下： 将一个连续序列表示成一个这样的&lt;K, V&gt;对，其中K为该连续序列的起点（最小的那个数，最大的也可），V为该连续序列的长度。很明显连续序列和&lt;K, V&gt;对是一一对应的。 于是就可以用两个map结构（为达到\\(O(1)\\)水平，C++用unordered_map&lt;K, V&gt;， Java用HashMmap&lt;K, V&gt;），分别为left和right，记录下所有以K为起点（终点）的连续序列的最大长度V。有了这两个map，每次添加新元素\\(X\\)的时候便可以通过left与right找到以\\(X+1\\)为起点的连续序列的最大长度以及以\\(X-1\\)为终点的连续序列的最大长度，显然这两个连续序列加上\\(X\\)能组成一个更长的序列。 代码 12345678910111213141516171819202122232425262728293031class Solution &#123; void updateMax(unordered_map&lt;int, int&gt; &amp;mp, int pos, int val) &#123; auto it = mp.find(pos); if (it == mp.end()) mp.insert(make_pair(pos, val)); else it-&gt;second = max(it-&gt;second, val); &#125; void updateMin(unordered_map&lt;int, int&gt; &amp;mp, int pos, int val) &#123; auto it = mp.find(pos); if (it == mp.end()) mp.insert(make_pair(pos, val)); else it-&gt;second = min(it-&gt;second, val); &#125;public: int longestConsecutive(vector&lt;int&gt;&amp; nums) &#123; unordered_map&lt;int, int&gt; left, right; // left: started a x, leftmost pos int ans = 0; for (int a : nums) &#123; int l = a, r = a; auto itl = left.find(a - 1); if (itl != left.end()) l = itl-&gt;second; auto itr = right.find(a + 1); if (itr != right.end()) r = itr-&gt;second; updateMax(right, l, r); updateMin(left, r, l); ans = max(ans, r - l + 1); &#125; return ans; &#125;&#125;;","categories":[],"tags":[{"name":"LeetCode","slug":"LeetCode","permalink":"http://yoursite.com/tags/LeetCode/"}]},{"title":"提取Windows Spotlight提供的漂亮壁纸","slug":"提取Windows-Spotlight提供的漂亮壁纸","date":"2017-11-11T02:53:10.000Z","updated":"2017-11-11T06:23:05.799Z","comments":true,"path":"2017/11/11/提取Windows-Spotlight提供的漂亮壁纸/","link":"","permalink":"http://yoursite.com/2017/11/11/提取Windows-Spotlight提供的漂亮壁纸/","excerpt":"Windows Spotlight Windows Spotlight（在中文系统里叫Windows聚焦）是一个系统集成的Feature，可以在锁屏界面上显示不同的背景图像并且定期自动更新。与Bing首页的背景图片差不多，Windows Spotlight提供的壁纸的质量都比较高，因此我们经常会希望能把这些壁纸保存下来用作桌面壁纸。","text":"Windows Spotlight Windows Spotlight（在中文系统里叫Windows聚焦）是一个系统集成的Feature，可以在锁屏界面上显示不同的背景图像并且定期自动更新。与Bing首页的背景图片差不多，Windows Spotlight提供的壁纸的质量都比较高，因此我们经常会希望能把这些壁纸保存下来用作桌面壁纸。 Naive的做法 在Google上找了一些解决方案，其基本做法都是到这个路径中去提取： %localappdata%/Packages/Microsoft.Windows.ContentDeliveryManager_cw5n1h2txyewy/LocalState/Assets 可以看到，在这个文件夹下的文件都是没有后缀名的，从文件大小上来看也不难发现仅有一部分的文件是图片。至于如何区分呢？一种比较Naive的方法是通过类似于ren *.* *.jpg这样的命令批量增加后缀名之后用肉眼把图片筛选出来。 但这样还是比较麻烦的，毕竟Windows Spotlight里面的资源图片是不定期更新的，如果每次都要走这个流程大概也没几个人能坚持下来吧。（魔方这个应用似乎是有一键提取图片的功能，但也是需要经常性地去使用这个功能，稍稍麻烦） Spotlight Watcher！ 所以基于这样的需求，我用Node.js写了一个工具，包含这几样功能： 定期触发（能够注册成一个系统服务，开机自动运行） 自动到Windows Spotlight的资源目录下面扫描，筛选出横屏的图片（每张壁纸都有提供横屏/竖屏两种状态）并保存到指定目录下 过滤重复的图片 源代码放在GitHub：Here 也发布到了NPM：Here 安装 前置要求： Node.js &gt;= 8.0.0 Windows 10 1607 或更高（才能找到Windows Spotlight） 然后只需要在命令行输入npm i -g spotlight即可。 配置与使用 通过spotlight config进行初始化设置： 然后就可以通过spotlight update手动触发一次提取，当然更推荐用spotlight install直接注册一个系统服务自动运行，以后只需要时不时去config时设置的目标文件夹就能收获一堆新壁纸了。 当然也可以直接把系统的壁纸幻灯片文件夹设为目标文件夹，更省心。 如果不想使用了，可以通过spotlight uninstall把之前安装的服务卸载掉。","categories":[],"tags":[{"name":"Node.js","slug":"Node-js","permalink":"http://yoursite.com/tags/Node-js/"},{"name":"Windows Spotlight","slug":"Windows-Spotlight","permalink":"http://yoursite.com/tags/Windows-Spotlight/"}]},{"title":"LeetCode 刷题记录 （九）","slug":"LeetCode-刷题记录-（九）","date":"2017-11-01T07:49:46.000Z","updated":"2017-11-10T11:18:36.581Z","comments":true,"path":"2017/11/01/LeetCode-刷题记录-（九）/","link":"","permalink":"http://yoursite.com/2017/11/01/LeetCode-刷题记录-（九）/","excerpt":"K Inverse Pairs Array https://leetcode.com/problems/k-inverse-pairs-array/description/ 题意 给定\\(n\\)和\\(k\\)，计算由\\(1\\)到\\(n\\)的\\(n\\)个正整数组成的所有序列中，恰有\\(k\\)对逆序对的序列个数。（因为答案较大，因此只需计算答案模\\(10^9+7\\)的余数。","text":"K Inverse Pairs Array https://leetcode.com/problems/k-inverse-pairs-array/description/ 题意 给定\\(n\\)和\\(k\\)，计算由\\(1\\)到\\(n\\)的\\(n\\)个正整数组成的所有序列中，恰有\\(k\\)对逆序对的序列个数。（因为答案较大，因此只需计算答案模\\(10^9+7\\)的余数。 思路 考虑一个这样的序列，它由\\(1\\)~\\(n_1\\)这\\(n_1\\)个正整数组成。此时把一个\\(n_1+1\\)插入序列中，显然得到的长为\\(n_1+1\\)的新序列中的逆序对个数仅与原序列中的逆序对个数、还有插入的\\(n_1+1\\)的位置有关（因为它比原序列中的任何数都大，因此在插入的位置后面的原序列当中的数字都会与\\(n_1+1\\)形成一个新的逆序对）。 于是得到状态转移： \\[ F_{i,j}=(\\sum_{k\\ge j-i+1\\land k\\ge0}^{}{F_{i-1,k}}) \\% (10^9 + 7) \\] \\(F_{i,j}\\)表示长度为\\(i\\)的序列中，满足有\\(j\\)个逆序对的解的数量（模\\(10^9+7\\)）。 然后加上和背包问题中类似的减少需要的内存空间的方法，可以在\\(O(n)\\)的时空复杂度下解决问题。 代码 123456789101112131415161718192021class Solution &#123;public: int kInversePairs(int n, int k) &#123; constexpr int MOD = 1e9 + 7; vector&lt;int&gt; f(k + 1); f[0] = 1; for (int i = 2; i &lt;= n; i++) &#123; int p = k + 1, sum = 0; for (int j = k; j &gt; 0; j--) &#123; while (p - 1 &gt;= 0 &amp;&amp; p - 1 &gt;= j - i + 1) sum = (sum + f[--p]) % MOD; int tmp = f[j]; f[j] = sum; sum = (sum + MOD - tmp) % MOD; &#125; &#125; return f[k]; &#125;&#125;;","categories":[],"tags":[{"name":"LeetCode","slug":"LeetCode","permalink":"http://yoursite.com/tags/LeetCode/"}]},{"title":"LeetCode 刷题记录 （八）","slug":"LeetCode-刷题记录-（八）","date":"2017-10-25T06:25:29.000Z","updated":"2017-11-10T11:19:13.319Z","comments":true,"path":"2017/10/25/LeetCode-刷题记录-（八）/","link":"","permalink":"http://yoursite.com/2017/10/25/LeetCode-刷题记录-（八）/","excerpt":"Flatten Nested List Iterator https://leetcode.com/problems/flatten-nested-list-iterator/description/ 题意 现在有一种新的嵌套数组类型，定义如下： NestedInteger可以表示一个整数，也可以表示为一个NestedInteger的数组。 现在要实现一个NestedIterator类，作为NestedInteger表示的嵌套数组的迭代器，它能够以该嵌套数组的“压平”后进行从左到右的迭代。 比如一个嵌套数组[1, [2, 3], 4, [5, [6]]]，迭代顺序就是1, 2, 3, 4, 5, 6。","text":"Flatten Nested List Iterator https://leetcode.com/problems/flatten-nested-list-iterator/description/ 题意 现在有一种新的嵌套数组类型，定义如下： NestedInteger可以表示一个整数，也可以表示为一个NestedInteger的数组。 现在要实现一个NestedIterator类，作为NestedInteger表示的嵌套数组的迭代器，它能够以该嵌套数组的“压平”后进行从左到右的迭代。 比如一个嵌套数组[1, [2, 3], 4, [5, [6]]]，迭代顺序就是1, 2, 3, 4, 5, 6。 思路 个人觉得这道题挺有意思的，比起算法，这题更像是一个语言题。 在一些动态类型的语言中（比如Python和JavaScript），这个问题经常遇到也比较容易解决。但在C++里面就比较难写了。 从嵌套数组的结构来分析，一个嵌套数组其实可以表示成一棵树，其中最底层的叶子节点就是各个整数元素，而非叶节点就是数组元素（空数组直接删掉不参与树的构建）。那么把这个嵌套数组压平的过程其实就是DFS的遍历过程。 但这道题所求的并不止是压平数组的结果，它还要求实现一个迭代器。也就是说这样一个DFS的遍历过程不是一口气完成的，而是每次调用next()方法都向前走一步。这也就要求有一个栈结构来保存执行上下文，手动模拟递归过程。 具体实现过程见代码。 代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687/** * // This is the interface that allows for creating nested lists. * // You should not implement it, or speculate about its implementation * class NestedInteger &#123; * public: * // Return true if this NestedInteger holds a single integer, rather than a nested list. * bool isInteger() const; * * // Return the single integer that this NestedInteger holds, if it holds a single integer * // The result is undefined if this NestedInteger holds a nested list * int getInteger() const; * * // Return the nested list that this NestedInteger holds, if it holds a nested list * // The result is undefined if this NestedInteger holds a single integer * const vector&lt;NestedInteger&gt; &amp;getList() const; * &#125;; */class NestedIterator &#123; typedef pair&lt;const vector&lt;NestedInteger&gt;*, vector&lt;NestedInteger&gt;::const_iterator&gt; Context; // second must be integer stack&lt;Context&gt; stk; void decompose(const NestedInteger &amp;ni) &#123; auto p = &amp;ni; while (!p-&gt;isInteger()) &#123; auto&amp; list = p-&gt;getList(); if (list.size()) &#123; // ni not an empty list auto context = make_pair(&amp;list, list.begin()); stk.push(context); p = &amp;*list.begin(); &#125; else break; &#125; &#125; int getCurrent() &#123; skipNull(); auto context = stk.top(); return context.second-&gt;getInteger(); &#125; bool isEmptyList(const NestedInteger &amp;ni) &#123; return !ni.isInteger() &amp;&amp; ni.getList().empty(); &#125; void moveNext() &#123; while (true) &#123; stk.top().second++; if (stk.top().second == stk.top().first-&gt;end()) &#123; stk.pop(); if (stk.empty()) break; &#125; else break; &#125; if (!stk.empty()) decompose(*stk.top().second); &#125; void skipNull() &#123; while (!stk.empty() &amp;&amp; isEmptyList(*stk.top().second)) moveNext(); &#125;public: NestedIterator(vector&lt;NestedInteger&gt; &amp;nestedList) &#123; if (nestedList.empty()) return; stk.push(make_pair(&amp;nestedList, nestedList.cbegin())); decompose(nestedList.front()); &#125; int next() &#123; int result = getCurrent(); moveNext(); return result; &#125; bool hasNext() &#123; skipNull(); return !stk.empty(); &#125;&#125;;/** * Your NestedIterator object will be instantiated and called as such: * NestedIterator i(nestedList); * while (i.hasNext()) cout &lt;&lt; i.next(); */","categories":[],"tags":[{"name":"LeetCode","slug":"LeetCode","permalink":"http://yoursite.com/tags/LeetCode/"}]},{"title":"LeetCode 刷题记录 （七）","slug":"LeetCode-刷题记录-（七）","date":"2017-10-18T12:57:18.000Z","updated":"2017-11-10T11:18:56.239Z","comments":true,"path":"2017/10/18/LeetCode-刷题记录-（七）/","link":"","permalink":"http://yoursite.com/2017/10/18/LeetCode-刷题记录-（七）/","excerpt":"Binary Tree Maximum Path Sum https://leetcode.com/problems/binary-tree-maximum-path-sum/description/ 题意 给定一棵二叉树，二叉树上每个节点有一个整数权值。求在这棵二叉树上经过的节点的权值和最长的路径的权值和大小（路径至少经过一个节点）。","text":"Binary Tree Maximum Path Sum https://leetcode.com/problems/binary-tree-maximum-path-sum/description/ 题意 给定一棵二叉树，二叉树上每个节点有一个整数权值。求在这棵二叉树上经过的节点的权值和最长的路径的权值和大小（路径至少经过一个节点）。 思路 对于一棵二叉树，上面的所有路径其实可以分为以下几种： 只经过左子树中的节点 只经过右子树中的节点 只经过左子树中的节点和根 只经过右子树中的节点和根 左右子树节点和根都经过 很显然，第五种路径其实是第三、四种路径和根节点的组合；另外几种路径也和对应的子树的子树的某几种路径相关。 于是就可以递归计算，对每个节点分别计算在相应子树中五种路径的最大权值和即可。 代码 LeetCode直接提供了TreeNode的定义： 123456789/*** Definition for a binary tree node.* struct TreeNode &#123;* int val;* TreeNode *left;* TreeNode *right;* TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;* &#125;;*/ 但上面挂载的信息还太少，又不能修改这个定义，于是只能新创建一个结构SolNode，添加一些成员，通过TreeNode进行构造。 因为SolNode在构造的时候会递归地对左右子树进行构造，正好和解题的顺序一样，所以干脆把解题过程也写在SolNode的构造函数里了。 1234567891011121314151617181920212223242526272829303132struct SolNode &#123; int val, leftMax, rightMax, midMax, ansMax; bool allNeg; int maxVal; SolNode *left, *right; SolNode(TreeNode *node) &#123; if (!node) &#123; ansMax = midMax = leftMax = rightMax = 0; allNeg = true; maxVal = -2e9; return; &#125; left = new SolNode(node-&gt;left); right = new SolNode(node-&gt;right); val = node-&gt;val; leftMax = val + max(max(left-&gt;leftMax, left-&gt;rightMax), 0); rightMax = val + max(max(right-&gt;leftMax, right-&gt;rightMax), 0); midMax = leftMax + rightMax - val; int t1 = max(left-&gt;ansMax, right-&gt;ansMax); int t2 = max(leftMax, rightMax); ansMax = max(max(t1, t2), midMax); maxVal = max(max(left-&gt;maxVal, right-&gt;maxVal), val); allNeg = left-&gt;allNeg &amp;&amp; right-&gt;allNeg &amp;&amp; val &lt; 0; &#125;&#125;;class Solution &#123;public: int maxPathSum(TreeNode* root) &#123; auto solNode = new SolNode(root); return solNode-&gt;allNeg ? solNode-&gt;maxVal : solNode-&gt;ansMax; &#125;&#125;; Minimum Window Substring https://leetcode.com/problems/minimum-window-substring/description/ 题意 给定两个字符串\\(S\\)和\\(T\\)（题目没说，假设由ascii从0-255的字符都有可能出现），求\\(S\\)的最短子串\\(S&#39;\\)，使得\\(T\\)中的每个字符在\\(S&#39;\\)中都出现。 Node: 如果字符\\(c\\)在\\(T\\)中出现多次，那么\\(c\\)在\\(S&#39;\\)中也应出现至少相同次数。 输入保证这样的最短子串是唯一的。 思路 其实题目标题中的Window就充满了暗示...... 用两个迭代器\\(i\\)与\\(pos\\)分别为指向满足要求的子串的头与尾（以下标0方向为尾）。 在初始时\\(pos=0\\)，\\(i\\)不断增大直到\\(S[0:i]\\)满足要求为止，此时\\(S[0:i]\\)是一个满足要求的子串（不一定最短）。然后\\(i\\)每次右移一位，记\\(i^{&#39;}=i+1\\)，此时得到的新子串\\(S[0:i^{&#39;}]\\)也必定满足要求，但由于这个子串的左端可能会有多余的、删掉也不妨碍子串满足要求的字符，于是一直右移\\(pos\\)直到没有多余字符为止。 具体实现见下面代码。 代码 12345678910111213141516171819202122232425262728293031class Solution &#123; int req[256], meet[256];public: string minWindow(string s, string t) &#123; if (s.length() &lt; t.length()) return \"\"; memset(req, 0, 256); memset(meet, 0, 256); int unMeet = 0; for (char c : t) &#123; if (!req[c]) unMeet++; req[c]++; &#125; int minLen = 2e9, minPos; bool ok = false; for (int i = 0, pos = 0; i &lt; s.length(); i++) &#123; meet[s[i]]++; if (meet[s[i]] == req[s[i]]) &#123; // just meet unMeet--; if (!unMeet) ok = true; &#125; while (meet[s[pos]] &gt; req[s[pos]]) meet[s[pos++]]--; if (ok &amp;&amp; i - pos + 1 &lt; minLen) &#123; minLen = i - pos + 1; minPos = pos; &#125; &#125; return ok ? s.substr(minPos, minLen) : \"\"; &#125;&#125;;","categories":[],"tags":[{"name":"LeetCode","slug":"LeetCode","permalink":"http://yoursite.com/tags/LeetCode/"}]},{"title":"LeetCode 刷题记录 （六）","slug":"LeetCode-刷题记录-（六）","date":"2017-10-13T07:19:51.000Z","updated":"2018-01-21T11:41:38.085Z","comments":true,"path":"2017/10/13/LeetCode-刷题记录-（六）/","link":"","permalink":"http://yoursite.com/2017/10/13/LeetCode-刷题记录-（六）/","excerpt":"Candy https://leetcode.com/problems/candy/description/ 题意 \\(N\\)个小朋友站成一行，每个小朋友有一个评级\\(R_i\\)。现在要给每个小朋友派发糖果，第\\(i\\)个小朋友得到的糖果的数量\\(C_i\\)须满足如下条件： \\(C_i\\ge1\\) 对于\\(|i-j|=1\\)，如果\\(R_i&gt;R_j\\)，则\\(C_i&gt;C_j\\) 计算最少需要的糖果总数。","text":"Candy https://leetcode.com/problems/candy/description/ 题意 \\(N\\)个小朋友站成一行，每个小朋友有一个评级\\(R_i\\)。现在要给每个小朋友派发糖果，第\\(i\\)个小朋友得到的糖果的数量\\(C_i\\)须满足如下条件： \\(C_i\\ge1\\) 对于\\(|i-j|=1\\)，如果\\(R_i&gt;R_j\\)，则\\(C_i&gt;C_j\\) 计算最少需要的糖果总数。 思路 根据要求递归计算即可，加上记忆化防止重复计算。时间复杂度为\\(\\mathcal{O}(N)\\)。 代码 1234567891011121314151617181920212223class Solution &#123; vector&lt;int&gt; res; vector&lt;int&gt; ratings; int calculate(int pos) &#123; if (pos &lt; 0 || pos &gt;= res.size()) return 0; if (res[pos] != -1) return res[pos]; int left = get(pos - 1) &lt; get(pos) ? calculate(pos - 1) : 0; int right = get(pos + 1) &lt; get(pos) ? calculate(pos + 1) : 0; return res[pos] = max(left, right) + 1; &#125; int get(int pos) &#123; return (pos &lt; 0 || pos &gt;= ratings.size()) ? 1e9 : ratings[pos]; &#125;public: int candy(vector&lt;int&gt;&amp; ratings) &#123; this-&gt;ratings = ratings; res.clear(); res.resize(ratings.size(), -1); int ans = 0; for (int i = 0; i &lt; res.size(); i++) ans += calculate(i); return ans; &#125;&#125;; Maximum Subarray https://leetcode.com/problems/maximum-subarray/description/ 题意 给定一个数组\\(A\\)，求它的最大子段和。 思路 经典的DP题。 \\(F_i\\)表示以\\(A_i\\)结尾的所有子段中能够得到的最大字段和，于是有： \\[ F_i=\\max\\{F_{i-1},0\\}+A_i \\] 初始有\\(F_0=A_0\\)。 时间复杂度为\\(\\mathcal{O}(N)\\)，\\(N\\)为数组中元素个数。 代码 1234567891011121314class Solution &#123;public: int maxSubArray(vector&lt;int&gt;&amp; nums) &#123; vector&lt;int&gt; f; f.resize(nums.size()); f[0] = nums[0]; int ans = f[0]; for (int i = 1; i &lt; nums.size(); i++) &#123; f[i] = max(f[i - 1], 0) + nums[i]; ans = max(ans, f[i]); &#125; return ans; &#125;&#125;;","categories":[],"tags":[{"name":"LeetCode","slug":"LeetCode","permalink":"http://yoursite.com/tags/LeetCode/"}]},{"title":"在Hexo中使用数学公式","slug":"在Hexo中使用数学公式","date":"2017-10-12T04:17:15.000Z","updated":"2017-11-10T11:19:30.805Z","comments":true,"path":"2017/10/12/在Hexo中使用数学公式/","link":"","permalink":"http://yoursite.com/2017/10/12/在Hexo中使用数学公式/","excerpt":"之前在写LeetCode解题报告的时候总是不可避免地要通过一些比较数学的方式来描述题解，原本认为Hexo自带的Markdown Renderer不支持公式渲染于是就用代码块将就了。后来越写越不能忍受，才下定决定一定要把公式功能加上。 \\(A_{i,j}\\)比A[i][j]酷多了啊！","text":"之前在写LeetCode解题报告的时候总是不可避免地要通过一些比较数学的方式来描述题解，原本认为Hexo自带的Markdown Renderer不支持公式渲染于是就用代码块将就了。后来越写越不能忍受，才下定决定一定要把公式功能加上。 \\(A_{i,j}\\)比A[i][j]酷多了啊！ 在查解决方案的时候发现很幸运地，现在我在用的主题Next其实已经集成了MathJax，只需要在themes/next/_config.yml里面把对应设置项打开就行了： 12345# MathJax Supportmathjax: enable: true per_page: false cdn: //cdn.bootcss.com/mathjax/2.7.1/latest.js?config=TeX-AMS-MML_HTMLorMML 刷新之后发现的确已经能显示数学公式了，但在需要用到下标的时候（例如打算使用$A_i$得到\\(A_i\\)），里面的下划线会和Markdown语法中的_斜体_语法冲突，也就是说，一旦有$A_i$一些其他的文本$B_i$这样的情况出现，里面的两个_会匹配成为Markdown的斜体标记，公式就渲染出错了。 一个Naive的解决方案就是在每一个下划线前面加转义符，也就是用\\_替代_，这样能防止被解析成斜体 但这实在是太麻烦了，谁想每次在写公式下标的时候都加个斜杠呢。 后来找到了一个几乎完美的解决方案：修改Hexo渲染Markdown时用的渲染引擎！ 在package.json里能看到Hexo原本用的是hexo-renderer-marked，把它换成hexo-renderer-pandoc即可。 Pandoc是一个十分强大的开源格式转换工具。 hexo-renderer-pandoc通过调用系统中的Pandoc来渲染Markdown，因此需要先在系统中安装Pandoc才能正常使用 12npm rm hexo-renderer-markednpm i hexo-renderer-pandoc 完美解决公式渲染问题，能在博客里面爽用MathJax写公式了（唯一的缺点是需要额外安装Pandoc，不能直接npm i解决所有依赖问题，但这又何妨呢）。","categories":[],"tags":[{"name":"乱讲","slug":"乱讲","permalink":"http://yoursite.com/tags/乱讲/"},{"name":"Hexo","slug":"Hexo","permalink":"http://yoursite.com/tags/Hexo/"}]},{"title":"LeetCode 刷题记录 （五）","slug":"LeetCode-刷题记录-（五）","date":"2017-10-11T06:38:47.000Z","updated":"2017-11-10T11:19:54.589Z","comments":true,"path":"2017/10/11/LeetCode-刷题记录-（五）/","link":"","permalink":"http://yoursite.com/2017/10/11/LeetCode-刷题记录-（五）/","excerpt":"Dungeon Game https://leetcode.com/problems/dungeon-game/description/ 题意 一个\\(m\\times n\\)的矩阵当中，一个骑士从左上角走到右下角，只能向右或向下移动。骑士有初始血量\\(H\\)，矩阵的每一格中有一个数值\\(A_{i,j}\\)表示移动到这一格时对血量的增减，计算能保证不在任意时刻血量降至0以下的最小初始血量\\(H_{min}\\)。","text":"Dungeon Game https://leetcode.com/problems/dungeon-game/description/ 题意 一个\\(m\\times n\\)的矩阵当中，一个骑士从左上角走到右下角，只能向右或向下移动。骑士有初始血量\\(H\\)，矩阵的每一格中有一个数值\\(A_{i,j}\\)表示移动到这一格时对血量的增减，计算能保证不在任意时刻血量降至0以下的最小初始血量\\(H_{min}\\)。 思路 因为只能向右或下移动，因此避免了走回路的情况。记\\(F_{i,j}\\)为走到以第\\(i\\)行第\\(j\\)列（从0开始）为起点，走到终点要求的最小初始血量。显然地，\\(F_{i,j}\\)只与\\(F_{i,j+1}\\)、\\(F_{i+1,j}\\)以及\\(A_{i,j}\\)相关。于是有下面的关系： \\[ F_{i,j}=max\\{0,-A_{i,j}+min\\{F_{i,j+1},F_{i+1,j}\\}\\} \\] 特别地，对于终点有： \\[ F_{m-1,n-1}=max\\{0, -A_{m-1,n-1}\\} \\] 上面的递推保证了在任意时刻血量均不会降为负数，因为题目里需要正数血量，因此最后的答案就是\\(F_{0,0}+1\\)。 代码 123456789101112131415161718class Solution &#123;public: int calculateMinimumHP(vector&lt;vector&lt;int&gt;&gt;&amp; dungeon) &#123; int n = dungeon.size(), m = dungeon.front().size(); vector&lt;vector&lt;int&gt;&gt; res; res.resize(n + 1); for (auto it = res.begin(); it != res.end(); it++) it-&gt;resize(m + 1, 1e9); res[n - 1][m - 1] = max(-dungeon[n - 1][m - 1], 0); for (int i = n - 1; i &gt;= 0; i--) &#123; for (int j = m - 1; j &gt;= 0; j--) &#123; if (i == n - 1 &amp;&amp; j == m - 1) continue; res[i][j] = -dungeon[i][j] + min(res[i][j + 1], res[i + 1][j]); res[i][j] = max(res[i][j], 0); &#125; &#125; return res[0][0] + 1; &#125;&#125;; Shortest Palindrome https://leetcode.com/problems/shortest-palindrome/description/ 题意 给定一个字符串\\(S\\)，在它前面增加若干字符得到\\(S&#39;\\)使得它成为一个回文字符串，求满足要求的最短的\\(S&#39;\\)。 思路 如果能将\\(S\\)分解为\\(S_1S_2\\)，其中\\(S_1\\)为回文串，那么只需要在\\(S_1S_2\\)前加上\\(S_2\\)的翻转\\(S&#39;_2\\)，得到的\\(S&#39;_2S_1S_2\\)就是一个回文字符串。 问题变为寻找一个最长的回文子串\\(S_1\\)。 这是一个经典的问题，可以使用Manacher算法解决。 代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748class Solution &#123; static string preprocess(const string&amp; s) &#123; string res; res.resize(s.size() * 2 + 1); for (int i = 0; i &lt; res.size(); i++) &#123; if (i % 2) res[i] = s[i / 2]; else res[i] = '#'; &#125; return res; &#125; static int mirror(int pos, int middle) &#123; return 2 * middle - pos; &#125; static int longestPrefixingPalidrome(const string&amp; s) &#123; string ss = preprocess(s); vector&lt;int&gt; rl = &#123; 0 &#125;; int maxRight = 0, pos = 0, ans = 0; for (int i = 1; i &lt; ss.length(); i++) &#123; int j; if (i &gt; maxRight) j = i; else &#123; // i &lt;= maxRight int knownLen = rl[mirror(i, pos)]; j = min(i + knownLen, maxRight); &#125; while (j &lt; ss.length() &amp;&amp; mirror(j, i) &gt;= 0 &amp;&amp; ss[j] == ss[mirror(j, i)]) j++; j--; rl.push_back(j - i); if (j &gt; maxRight) &#123; maxRight = j; pos = i; &#125; if (mirror(j, i) == 0) ans = max(ans, rl[i]); &#125; return ans; &#125;public: string shortestPalindrome(string s) &#123; int len = longestPrefixingPalidrome(s); auto left = s.substr(len); reverse(left.begin(), left.end()); return left + s; &#125;&#125;;","categories":[],"tags":[{"name":"LeetCode","slug":"LeetCode","permalink":"http://yoursite.com/tags/LeetCode/"}]},{"title":"LeetCode 刷题记录 （四）","slug":"LeetCode-刷题记录-（四）","date":"2017-09-27T06:30:54.000Z","updated":"2017-11-10T11:19:21.335Z","comments":true,"path":"2017/09/27/LeetCode-刷题记录-（四）/","link":"","permalink":"http://yoursite.com/2017/09/27/LeetCode-刷题记录-（四）/","excerpt":"Sliding Window Maximum https://leetcode.com/problems/sliding-window-maximum/description/ 题意 一个有n个数字的数组a，对于给定的k，对每一组连续的k个数组元素（即a[i...i+k-1] ），输出这k个元素中的最大值。","text":"Sliding Window Maximum https://leetcode.com/problems/sliding-window-maximum/description/ 题意 一个有n个数字的数组a，对于给定的k，对每一组连续的k个数组元素（即a[i...i+k-1] ），输出这k个元素中的最大值。 思路 注意到对于a[i]，如果存在j &gt; i使得a[j] &gt;= a[i]，那么对于所有末端位置大于等于j的k元组，a[i]都不可能会是这个k元组中的最大值，基于只可能出现以下几种情况： a[i]不在这个k元组中，此时a[i]自然不可能是这个k元组的最值； a[i]在这个k元组中，但因该k元组末端位置在j右侧，即a[j]也在k元组中，a[i]被a[j] 淘汰； 因此可以枚举k元组的右侧端点t，同时维护一个队列：每当t右移，则将a[t]加入队列尾，在加入前淘汰（移除）所有在队列中的不大于a[t]的元素。经过这一过程后的队列头就是以t为右侧端点的k元组的最大值。 代码 1234567891011121314151617class Solution &#123;public: vector&lt;int&gt; maxSlidingWindow(vector&lt;int&gt;&amp; nums, int k) &#123; list&lt;pair&lt;int, int&gt;&gt; q; vector&lt;int&gt; res; for (int i = 0; i &lt; nums.size(); i++) &#123; while (!q.empty() &amp;&amp; q.front().second &lt; i - k + 1) q.pop_front(); while (!q.empty() &amp;&amp; q.back().first &lt; nums[i]) q.pop_back(); q.push_back(&#123; nums[i], i &#125;); if (i &gt;= k - 1) res.push_back(q.front().first); &#125; return res; &#125;&#125;; Binary Tree Postorder Traversal https://leetcode.com/problems/binary-tree-postorder-traversal/description/ 题意 给定一个二叉树，以后序遍历方式输出所有的节点。（这题居然也是Hard） 代码 12345678910111213141516171819202122232425/** * Definition for a binary tree node. * struct TreeNode &#123; * int val; * TreeNode *left; * TreeNode *right; * TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125; * &#125;; */class Solution &#123; vector&lt;int&gt; res;public: vector&lt;int&gt; postorderTraversal(TreeNode* root) &#123; res.clear(); traverse(root); return res; &#125; void traverse(TreeNode* root) &#123; if (!root) return; traverse(root-&gt;left); traverse(root-&gt;right); res.push_back(root-&gt;val); &#125;&#125;;","categories":[],"tags":[{"name":"LeetCode","slug":"LeetCode","permalink":"http://yoursite.com/tags/LeetCode/"}]},{"title":"LeetCode-刷题记录（三）","slug":"LeetCode-刷题记录-（三）","date":"2017-09-20T02:53:18.000Z","updated":"2017-11-10T11:18:58.990Z","comments":true,"path":"2017/09/20/LeetCode-刷题记录-（三）/","link":"","permalink":"http://yoursite.com/2017/09/20/LeetCode-刷题记录-（三）/","excerpt":"Interleaving String https://leetcode.com/problems/interleaving-string/description/ 题意 给定三个字符串s1、s2、s3，判断s3是否是由s1与s2交错构成。 比如&quot;abc&quot;就是由&quot;ac&quot;与&quot;b&quot;交错构成的，而&quot;cab&quot;不是。","text":"Interleaving String https://leetcode.com/problems/interleaving-string/description/ 题意 给定三个字符串s1、s2、s3，判断s3是否是由s1与s2交错构成。 比如&quot;abc&quot;就是由&quot;ac&quot;与&quot;b&quot;交错构成的，而&quot;cab&quot;不是。 思路 用类似动态规划的思路，dp[i][j]表示是否存在一个交错方式使得s1的前i位与s2的前j位交错能够生成s3的前i+j位。 于是有这样的状态关系：dp[i][j] = (dp[i-1][j] &amp;&amp; s1[i] == s3[i+j]) || (dp[i][j-1] &amp;&amp; d2[j] == s3[i+j])。 实现一下递推就好了，一般可以用记忆化或者类似BFS的递推形式，下面我用的是后一种方法。 代码 123456789101112131415161718192021222324252627282930313233class Solution &#123;public: bool isInterleave(string s1, string s2, string s3) &#123; if (s1.size() + s2.size() != s3.size()) return false; vector&lt;vector&lt;bool&gt;&gt; dp; dp.resize(s1.size() + 1); for (auto it = dp.begin(); it != dp.end(); it++) it-&gt;resize(s2.size() + 1, false); dp[0][0] = true; list&lt;pair&lt;int, int&gt;&gt; li = &#123; &#123;0, 0&#125; &#125;; while (!li.empty()) &#123; auto p = li.front(); li.pop_front(); dp[p.first][p.second] = true; if (p.first + p.second + 1 &gt; s3.size()) continue; char next = s3[p.first + p.second]; if (p.first &lt; s1.size() &amp;&amp; s1[p.first] == next) &#123; if (!dp[p.first + 1][p.second]) &#123; dp[p.first + 1][p.second] = true; li.push_back(&#123; p.first + 1, p.second &#125;); &#125; &#125; if (p.second &lt; s2.size() &amp;&amp; s2[p.second] == next) &#123; if (!dp[p.first][p.second + 1]) &#123; dp[p.first][p.second + 1] = true; li.push_back(&#123; p.first, p.second + 1 &#125;); &#125; &#125; &#125; return dp[s1.size()][s2.size()]; &#125;&#125;;","categories":[],"tags":[{"name":"LeetCode","slug":"LeetCode","permalink":"http://yoursite.com/tags/LeetCode/"}]},{"title":"LeetCode 刷题记录 （二）","slug":"LeetCode-刷题记录-（二）","date":"2017-09-12T07:40:04.000Z","updated":"2017-11-10T11:19:01.092Z","comments":true,"path":"2017/09/12/LeetCode-刷题记录-（二）/","link":"","permalink":"http://yoursite.com/2017/09/12/LeetCode-刷题记录-（二）/","excerpt":"Regular Expression Matching https://leetcode.com/problems/regular-expression-matching/description/ 题意 给定一个正则表达式，和一个字符串，判断给定的正则表达式是否与给定的字符串匹配。 这里的正则表达式是简化版的，只有. 与*两种元字符，而且只要求判断是否整体匹配（即整个字符串都是匹配的），所以比实现一个完整的字符串简单多了。","text":"Regular Expression Matching https://leetcode.com/problems/regular-expression-matching/description/ 题意 给定一个正则表达式，和一个字符串，判断给定的正则表达式是否与给定的字符串匹配。 这里的正则表达式是简化版的，只有. 与*两种元字符，而且只要求判断是否整体匹配（即整个字符串都是匹配的），所以比实现一个完整的字符串简单多了。 非常暴力的做法 直接上带正则表达式支持的语言就好（逃 比如JavaScript： 123456/** * @param &#123;string&#125; s * @param &#123;string&#125; p * @return &#123;boolean&#125; */const isMatch = (s, p) =&gt; !!s.match(new RegExp(`^$&#123;p&#125;$`)); 完事。 没那么暴力的做法 解题思路 记待匹配串为s，正则表达式串为p，n为s的长度，m为p的长度。 记n、m分别为待匹配串与正则表达式串的长度， 并级。 以类似动态规划的思路，以f[i][j]表示字符串匹配到第i位、正则串匹配到第j位的可行性（那么最终的匹配结果就是f[n][m]）。因此一共有mn个状态。在最坏情况下，需要把所有状态的结果都计算出来，因此时间复杂度为O(mn)。 状态的转移相对比较简单： 对于最简单的字符匹配，有f[i + 1][j + 1] = f[i][j]（s[i + 1] == p[j + 1]时） 对于.*与c*的匹配，有f[i + k][j + 2] = f[i][j]（其中k = 0, 1, ...，需满足s[i + 1] == s[i + 2] == ... == s[i + k] = c 或 c == '.' 。其中c为被* 修饰的待匹配字符） 具体实现见后面的代码。 坑点 边界条件比较复杂。 代码 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152class Solution &#123;public: bool isMatch(string ss, string pp) &#123; s = ' ' + ss; p = ' ' + pp; res.resize(s.size()); calculated.resize(s.size()); for (int i = 0; i &lt; s.size(); i++) &#123; // 初始化 res[i].clear(); res[i].resize(p.size(), false); calculated[i].clear(); calculated[i].resize(p.size(), false); &#125; match(0, 0); return res[s.size() - 1][p.size() - 1]; &#125; void match(int i, int j) &#123; if (i &gt;= s.size() || j &gt;= p.size()) return; if (calculated[i][j]) return; res[i][j] = calculated[i][j] = true; if (j &lt; p.size() - 1) &#123; // regexp remained bool starMatch = false; if (j &lt; p.size() - 2 &amp;&amp; p[j + 2] == '*') starMatch = true; if (i &lt; s.size() - 1) &#123; char toMatch = p[j + 1]; bool anyMatch = toMatch == '.'; if (starMatch) &#123; int k = i; while (k &lt; s.size()) &#123; match(k, j + 2); if (k &lt; s.size() - 1 &amp;&amp; (anyMatch || s[k + 1] == toMatch)) k++; else break; &#125; &#125; else &#123; if (anyMatch || s[i + 1] == toMatch) match(i + 1, j + 1); &#125; &#125; else &#123; if (starMatch) match(i, j + 2); &#125; &#125; &#125;private: string s, p; vector&lt;vector&lt;bool&gt;&gt; res, calculated;&#125;;","categories":[],"tags":[{"name":"LeetCode","slug":"LeetCode","permalink":"http://yoursite.com/tags/LeetCode/"}]},{"title":"LeetCode 刷题记录 （一）","slug":"LeetCode-刷题记录-（一）","date":"2017-09-08T07:20:41.000Z","updated":"2017-11-10T11:18:52.480Z","comments":true,"path":"2017/09/08/LeetCode-刷题记录-（一）/","link":"","permalink":"http://yoursite.com/2017/09/08/LeetCode-刷题记录-（一）/","excerpt":"merge-k-sorted-lists https://leetcode.com/problems/merge-k-sorted-lists/description/ 题意 Merge k sorted linked lists and return it as one sorted list. Analyze and describe its complexity. 给定k个已排序（升序）的链表，将他们合成为一个大的已排序链表。","text":"merge-k-sorted-lists https://leetcode.com/problems/merge-k-sorted-lists/description/ 题意 Merge k sorted linked lists and return it as one sorted list. Analyze and describe its complexity. 给定k个已排序（升序）的链表，将他们合成为一个大的已排序链表。 解题思路 当k=2时就是一个典型的Merge Sort的情况，在这时就只需要每次比较两个待归并链表的首项并把较小的那一项加到新的已排序链表的尾部即可。 扩展到k路归并的话，思路同样是取k个待归并列表的首项并将最小的一项加到结果链表的尾部。对于比较k个首项的大小并获得最小项的过程，我们可以维护一个由所有链表头组成的最小堆（直接用algorithm库的make_heap push_heap pop_heap 完成，省去自己实现），这样每次得到最小项所需的复杂度为O(1) ，添加删除堆节点的复杂度为O(logK) 。最终的复杂度为O(NlogK)，其中N为k个链表的总节点数。 坑点 会给空链表，即输入的vector中会有NULL项。 代码 1234567891011121314151617181920212223242526272829303132333435/** * Definition for singly-linked list. * struct ListNode &#123; * int val; * ListNode *next; * ListNode(int x) : val(x), next(NULL) &#123;&#125; * &#125;; */#include &lt;algorithm&gt;class Solution &#123;public: ListNode* mergeKLists(vector&lt;ListNode*&gt;&amp; lists) &#123; auto head = new ListNode(0), tail = head; vector&lt;ListNode*&gt; heap; for (auto it = lists.begin(); it != lists.end(); it++) &#123; auto node = *it; if (node) heap.push_back(node); &#125; auto comp = [](ListNode* a, ListNode* b) &#123; return a-&gt;val &gt; b-&gt;val; &#125;; make_heap(heap.begin(), heap.end(), comp); while (heap.size()) &#123; pop_heap(heap.begin(), heap.end(), comp); ListNode* selected = heap.back(); heap.pop_back(); tail = tail-&gt;next = new ListNode(selected-&gt;val); if (selected-&gt;next) &#123; heap.push_back(selected-&gt;next); push_heap(heap.begin(), heap.end(), comp); &#125; &#125; return head-&gt;next; &#125;&#125;;","categories":[],"tags":[{"name":"LeetCode","slug":"LeetCode","permalink":"http://yoursite.com/tags/LeetCode/"}]},{"title":"Hello Blog","slug":"Hello-Blog","date":"2017-09-07T04:03:05.000Z","updated":"2017-11-10T11:19:26.444Z","comments":true,"path":"2017/09/07/Hello-Blog/","link":"","permalink":"http://yoursite.com/2017/09/07/Hello-Blog/","excerpt":"作为一个新搭的Blog，总得写点什么在开头。","text":"作为一个新搭的Blog，总得写点什么在开头。 怎么又新搭了一个blog？ 其实在这背后，有一个十分悲伤的故事。 其实早在几个月前我就已经用Vue.js手写了一个SPA版的blog放在GitHub Page上了，采用的是和Hexo类似的生成器-静态网页的架构。放在GitHub Page上的只是编译后的静态网页文件，而核心的生成器部分只放在了本地的仓库里，而这个仓库在重装系统时以“反正都在GitHub上有，删了就删了吧“这样的智障思路非常爽快地删掉了。 是不是很悲伤。 总之 我那个可怜的SPA Blog已经消散在硬盘里了（反正写得也很简陋），在可以预见的未来里也没有从零开始搭一个blog的时间，就这样呗。 写点什么？ 想写什么写什么。学习笔记也好，自己写的教程也好，开发时的入坑出坑历程也好都做个记录。 以后不会忘记都做过些什么。","categories":[],"tags":[{"name":"乱讲","slug":"乱讲","permalink":"http://yoursite.com/tags/乱讲/"}]}]}