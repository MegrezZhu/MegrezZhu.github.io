{"meta":{"title":"Megrez","subtitle":"Everything is for DOPAMINE","description":"Everything is for DOPAMINE","author":"Zhu Chu","url":"http://yoursite.com"},"pages":[{"title":"tags","date":"2017-09-07T05:12:01.000Z","updated":"2017-09-07T05:13:11.482Z","comments":true,"path":"tags/index.html","permalink":"http://yoursite.com/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"LeetCode 刷题记录 （一）","slug":"LeetCode-刷题记录-（一）","date":"2017-09-08T07:20:41.000Z","updated":"2017-09-08T07:45:03.537Z","comments":true,"path":"2017/09/08/LeetCode-刷题记录-（一）/","link":"","permalink":"http://yoursite.com/2017/09/08/LeetCode-刷题记录-（一）/","excerpt":"","text":"https://leetcode.com/problems/merge-k-sorted-lists/description/ 题意 Merge k sorted linked lists and return it as one sorted list. Analyze and describe its complexity. 给定k个已排序（升序）的链表，将他们合成为一个大的已排序链表。 解题思路当k=2时就是一个典型的Merge Sort的情况，在这时就只需要每次比较两个待归并链表的首项并把较小的那一项加到新的已排序链表的尾部即可。 扩展到k路归并的话，思路同样是取k个待归并列表的首项并将最小的一项加到结果链表的尾部。对于比较k个首项的大小并获得最小项的过程，我们可以维护一个由所有链表头组成的最小堆（直接用algorithm库的make_heap push_heap pop_heap 完成，省去自己实现），这样每次得到最小项所需的复杂度为O(1) ，添加删除堆节点的复杂度为O(logK) 。最终的复杂度为O(NlogK)，其中N为k个链表的总节点数。 坑点会给空链表，即输入的vector中会有NULL项。 代码1234567891011121314151617181920212223242526272829303132333435/** * Definition for singly-linked list. * struct ListNode &#123; * int val; * ListNode *next; * ListNode(int x) : val(x), next(NULL) &#123;&#125; * &#125;; */#include &lt;algorithm&gt;class Solution &#123;public: ListNode* mergeKLists(vector&lt;ListNode*&gt;&amp; lists) &#123; auto head = new ListNode(0), tail = head; vector&lt;ListNode*&gt; heap; for (auto it = lists.begin(); it != lists.end(); it++) &#123; auto node = *it; if (node) heap.push_back(node); &#125; auto comp = [](ListNode* a, ListNode* b) &#123; return a-&gt;val &gt; b-&gt;val; &#125;; make_heap(heap.begin(), heap.end(), comp); while (heap.size()) &#123; pop_heap(heap.begin(), heap.end(), comp); ListNode* selected = heap.back(); heap.pop_back(); tail = tail-&gt;next = new ListNode(selected-&gt;val); if (selected-&gt;next) &#123; heap.push_back(selected-&gt;next); push_heap(heap.begin(), heap.end(), comp); &#125; &#125; return head-&gt;next; &#125;&#125;;","categories":[],"tags":[{"name":"LeetCode","slug":"LeetCode","permalink":"http://yoursite.com/tags/LeetCode/"}]},{"title":"Hello Blog","slug":"Hello-Blog","date":"2017-09-07T04:03:05.000Z","updated":"2017-09-07T13:10:47.297Z","comments":true,"path":"2017/09/07/Hello-Blog/","link":"","permalink":"http://yoursite.com/2017/09/07/Hello-Blog/","excerpt":"","text":"作为一个新搭的Blog，总得写点什么在开头。 怎么又新搭了一个blog？其实在这背后，有一个十分悲伤的故事。 其实早在几个月前我就已经用Vue.js手写了一个SPA版的blog放在GitHub Page上了，采用的是和Hexo类似的生成器-静态网页的架构。放在GitHub Page上的只是编译后的静态网页文件，而核心的生成器部分只放在了本地的仓库里，而这个仓库在重装系统时以“反正都在GitHub上有，删了就删了吧“这样的智障思路非常爽快地删掉了。 是不是很悲伤。 总之我那个可怜的SPA Blog已经消散在硬盘里了（反正写得也很简陋），在可以预见的未来里也没有从零开始搭一个blog的时间，就这样呗。 写点什么？想写什么写什么。学习笔记也好，自己写的教程也好，开发时的入坑出坑历程也好都做个记录。 以后不会忘记都做过些什么。","categories":[],"tags":[{"name":"乱讲","slug":"乱讲","permalink":"http://yoursite.com/tags/乱讲/"}]}]}