{"meta":{"title":"Megrez","subtitle":"Everything is for DOPAMINE","description":"Everything is for DOPAMINE","author":"Zhu Chu","url":"http://yoursite.com"},"pages":[{"title":"tags","date":"2017-09-07T05:12:01.000Z","updated":"2017-09-07T05:13:11.482Z","comments":true,"path":"tags/index.html","permalink":"http://yoursite.com/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"LeetCode 刷题记录 （五）","slug":"LeetCode-刷题记录-（五）","date":"2017-10-11T06:38:47.000Z","updated":"2017-10-11T08:03:18.031Z","comments":true,"path":"2017/10/11/LeetCode-刷题记录-（五）/","link":"","permalink":"http://yoursite.com/2017/10/11/LeetCode-刷题记录-（五）/","excerpt":"","text":"Dungeon Game https://leetcode.com/problems/dungeon-game/description/ 题意 一个\\(m\\times n\\)的矩阵当中，一个骑士从左上角走到右下角，只能向右或向下移动。骑士有初始血量\\(H\\)，矩阵的每一格中有一个数值\\(A_{i,j}\\)表示移动到这一格时对血量的增减，计算能保证不在任意时刻血量降至0以下的最小初始血量\\(H_{min}\\)。 思路 因为只能向右或下移动，因此避免了走回路的情况。记\\(F_{i,j}\\)为走到第\\(i\\)行第\\(j\\)列要求的最小初始血量。显然地，\\(F_{i,j}\\)只与\\(F_{i,j+1}\\)、\\(F_{i+1,j}\\)以及\\(A_{i,j}\\)相关。于是有下面的关系： \\[ F_{i,j}=max\\{0,-A_{i,j}+min\\{F_{i,j+1},F_{i+1,j}\\}\\} \\] 特别地，对于终点有： \\[ F_{m,n}=max\\{0, -A_{m,n}\\} \\] 上面的递推保证了在任意时刻血量均不会降为负数，因为题目里需要正数血量，因此最后的答案就是\\(F_{m,n}+1\\)。 代码 123456789101112131415161718class Solution &#123;public: int calculateMinimumHP(vector&lt;vector&lt;int&gt;&gt;&amp; dungeon) &#123; int n = dungeon.size(), m = dungeon.front().size(); vector&lt;vector&lt;int&gt;&gt; res; res.resize(n + 1); for (auto it = res.begin(); it != res.end(); it++) it-&gt;resize(m + 1, 1e9); res[n - 1][m - 1] = max(-dungeon[n - 1][m - 1], 0); for (int i = n - 1; i &gt;= 0; i--) &#123; for (int j = m - 1; j &gt;= 0; j--) &#123; if (i == n - 1 &amp;&amp; j == m - 1) continue; res[i][j] = -dungeon[i][j] + min(res[i][j + 1], res[i + 1][j]); res[i][j] = max(res[i][j], 0); &#125; &#125; return res[0][0] + 1; &#125;&#125;; Shortest Palindrome https://leetcode.com/problems/shortest-palindrome/description/ 题意 给定一个字符串\\(S\\)，在它前面增加若干字符得到\\(S&#39;\\)使得它成为一个回文字符串，求满足要求的最短的\\(S&#39;\\)。 思路 如果能将\\(S\\)分解为\\(S_1S_2\\)，其中\\(S_1\\)为回文串，那么只需要在\\(S_1S_2\\)前加上\\(S_2\\)的翻转\\(S&#39;_2\\)，得到的\\(S&#39;_2S_1S_2\\)就是一个回文字符串。 问题变为寻找一个最长的回文子串\\(S_1\\)。 这是一个经典的问题，可以使用Manacher算法解决。 代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748class Solution &#123; static string preprocess(const string&amp; s) &#123; string res; res.resize(s.size() * 2 + 1); for (int i = 0; i &lt; res.size(); i++) &#123; if (i % 2) res[i] = s[i / 2]; else res[i] = '#'; &#125; return res; &#125; static int mirror(int pos, int middle) &#123; return 2 * middle - pos; &#125; static int longestPrefixingPalidrome(const string&amp; s) &#123; string ss = preprocess(s); vector&lt;int&gt; rl = &#123; 0 &#125;; int maxRight = 0, pos = 0, ans = 0; for (int i = 1; i &lt; ss.length(); i++) &#123; int j; if (i &gt; maxRight) j = i; else &#123; // i &lt;= maxRight int knownLen = rl[mirror(i, pos)]; j = min(i + knownLen, maxRight); &#125; while (j &lt; ss.length() &amp;&amp; mirror(j, i) &gt;= 0 &amp;&amp; ss[j] == ss[mirror(j, i)]) j++; j--; rl.push_back(j - i); if (j &gt; maxRight) &#123; maxRight = j; pos = i; &#125; if (mirror(j, i) == 0) ans = max(ans, rl[i]); &#125; return ans; &#125;public: string shortestPalindrome(string s) &#123; int len = longestPrefixingPalidrome(s); auto left = s.substr(len); reverse(left.begin(), left.end()); return left + s; &#125;&#125;;","categories":[],"tags":[{"name":"LeetCode","slug":"LeetCode","permalink":"http://yoursite.com/tags/LeetCode/"}]},{"title":"LeetCode 刷题记录 （四）","slug":"LeetCode-刷题记录-（四）","date":"2017-09-27T06:30:54.000Z","updated":"2017-09-27T07:06:44.818Z","comments":true,"path":"2017/09/27/LeetCode-刷题记录-（四）/","link":"","permalink":"http://yoursite.com/2017/09/27/LeetCode-刷题记录-（四）/","excerpt":"","text":"Sliding Window Maximum https://leetcode.com/problems/sliding-window-maximum/description/ 题意 一个有n个数字的数组a，对于给定的k，对每一组连续的k个数组元素（即a[i...i+k-1] ），输出这k个元素中的最大值。 思路 注意到对于a[i]，如果存在j &gt; i使得a[j] &gt;= a[i]，那么对于所有末端位置大于等于j的k元组，a[i]都不可能会是这个k元组中的最大值，基于只可能出现以下几种情况： a[i]不在这个k元组中，此时a[i]自然不可能是这个k元组的最值； a[i]在这个k元组中，但因该k元组末端位置在j右侧，即a[j]也在k元组中，a[i]被a[j] 淘汰； 因此可以枚举k元组的右侧端点t，同时维护一个队列：每当t右移，则将a[t]加入队列尾，在加入前淘汰（移除）所有在队列中的不大于a[t]的元素。经过这一过程后的队列头就是以t为右侧端点的k元组的最大值。 代码 1234567891011121314151617class Solution &#123;public: vector&lt;int&gt; maxSlidingWindow(vector&lt;int&gt;&amp; nums, int k) &#123; list&lt;pair&lt;int, int&gt;&gt; q; vector&lt;int&gt; res; for (int i = 0; i &lt; nums.size(); i++) &#123; while (!q.empty() &amp;&amp; q.front().second &lt; i - k + 1) q.pop_front(); while (!q.empty() &amp;&amp; q.back().first &lt; nums[i]) q.pop_back(); q.push_back(&#123; nums[i], i &#125;); if (i &gt;= k - 1) res.push_back(q.front().first); &#125; return res; &#125;&#125;; Binary Tree Postorder Traversal https://leetcode.com/problems/binary-tree-postorder-traversal/description/ 题意 给定一个二叉树，以后序遍历方式输出所有的节点。（这题居然也是Hard） 代码 12345678910111213141516171819202122232425/** * Definition for a binary tree node. * struct TreeNode &#123; * int val; * TreeNode *left; * TreeNode *right; * TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125; * &#125;; */class Solution &#123; vector&lt;int&gt; res;public: vector&lt;int&gt; postorderTraversal(TreeNode* root) &#123; res.clear(); traverse(root); return res; &#125; void traverse(TreeNode* root) &#123; if (!root) return; traverse(root-&gt;left); traverse(root-&gt;right); res.push_back(root-&gt;val); &#125;&#125;;","categories":[],"tags":[{"name":"LeetCode","slug":"LeetCode","permalink":"http://yoursite.com/tags/LeetCode/"}]},{"title":"LeetCode-刷题记录（三）","slug":"LeetCode-刷题记录-（三）","date":"2017-09-20T02:53:18.000Z","updated":"2017-09-20T03:23:52.351Z","comments":true,"path":"2017/09/20/LeetCode-刷题记录-（三）/","link":"","permalink":"http://yoursite.com/2017/09/20/LeetCode-刷题记录-（三）/","excerpt":"","text":"Interleaving String https://leetcode.com/problems/interleaving-string/description/ 题意 给定三个字符串s1、s2、s3，判断s3是否是由s1与s2交错构成。 比如&quot;abc&quot;就是由&quot;ac&quot;与&quot;b&quot;交错构成的，而&quot;cab&quot;不是。 思路 用类似动态规划的思路，dp[i][j]表示是否存在一个交错方式使得s1的前i位与s2的前j位交错能够生成s3的前i+j位。 于是有这样的状态关系：dp[i][j] = (dp[i-1][j] &amp;&amp; s1[i] == s3[i+j]) || (dp[i][j-1] &amp;&amp; d2[j] == s3[i+j])。 实现一下递推就好了，一般可以用记忆化或者类似BFS的递推形式，下面我用的是后一种方法。 代码 123456789101112131415161718192021222324252627282930313233class Solution &#123;public: bool isInterleave(string s1, string s2, string s3) &#123; if (s1.size() + s2.size() != s3.size()) return false; vector&lt;vector&lt;bool&gt;&gt; dp; dp.resize(s1.size() + 1); for (auto it = dp.begin(); it != dp.end(); it++) it-&gt;resize(s2.size() + 1, false); dp[0][0] = true; list&lt;pair&lt;int, int&gt;&gt; li = &#123; &#123;0, 0&#125; &#125;; while (!li.empty()) &#123; auto p = li.front(); li.pop_front(); dp[p.first][p.second] = true; if (p.first + p.second + 1 &gt; s3.size()) continue; char next = s3[p.first + p.second]; if (p.first &lt; s1.size() &amp;&amp; s1[p.first] == next) &#123; if (!dp[p.first + 1][p.second]) &#123; dp[p.first + 1][p.second] = true; li.push_back(&#123; p.first + 1, p.second &#125;); &#125; &#125; if (p.second &lt; s2.size() &amp;&amp; s2[p.second] == next) &#123; if (!dp[p.first][p.second + 1]) &#123; dp[p.first][p.second + 1] = true; li.push_back(&#123; p.first, p.second + 1 &#125;); &#125; &#125; &#125; return dp[s1.size()][s2.size()]; &#125;&#125;;","categories":[],"tags":[{"name":"LeetCode","slug":"LeetCode","permalink":"http://yoursite.com/tags/LeetCode/"}]},{"title":"LeetCode 刷题记录 （二）","slug":"LeetCode-刷题记录-（二）","date":"2017-09-12T07:40:04.000Z","updated":"2017-09-13T09:12:08.389Z","comments":true,"path":"2017/09/12/LeetCode-刷题记录-（二）/","link":"","permalink":"http://yoursite.com/2017/09/12/LeetCode-刷题记录-（二）/","excerpt":"","text":"Regular Expression Matching https://leetcode.com/problems/regular-expression-matching/description/ 题意 给定一个正则表达式，和一个字符串，判断给定的正则表达式是否与给定的字符串匹配。 这里的正则表达式是简化版的，只有. 与*两种元字符，而且只要求判断是否整体匹配（即整个字符串都是匹配的），所以比实现一个完整的字符串简单多了。 非常暴力的做法 直接上带正则表达式支持的语言就好（逃 比如JavaScript： 123456/** * @param &#123;string&#125; s * @param &#123;string&#125; p * @return &#123;boolean&#125; */const isMatch = (s, p) =&gt; !!s.match(new RegExp(`^$&#123;p&#125;$`)); 完事。 没那么暴力的做法 解题思路 记待匹配串为s，正则表达式串为p，n为s的长度，m为p的长度。 记n、m分别为待匹配串与正则表达式串的长度， 并级。 以类似动态规划的思路，以f[i][j]表示字符串匹配到第i位、正则串匹配到第j位的可行性（那么最终的匹配结果就是f[n][m]）。因此一共有mn个状态。在最坏情况下，需要把所有状态的结果都计算出来，因此时间复杂度为O(mn)。 状态的转移相对比较简单： 对于最简单的字符匹配，有f[i + 1][j + 1] = f[i][j]（s[i + 1] == p[j + 1]时） 对于.*与c*的匹配，有f[i + k][j + 2] = f[i][j]（其中k = 0, 1, ...，需满足s[i + 1] == s[i + 2] == ... == s[i + k] = c 或 c == '.' 。其中c为被* 修饰的待匹配字符） 具体实现见后面的代码。 坑点 边界条件比较复杂。 代码 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152class Solution &#123;public: bool isMatch(string ss, string pp) &#123; s = ' ' + ss; p = ' ' + pp; res.resize(s.size()); calculated.resize(s.size()); for (int i = 0; i &lt; s.size(); i++) &#123; // 初始化 res[i].clear(); res[i].resize(p.size(), false); calculated[i].clear(); calculated[i].resize(p.size(), false); &#125; match(0, 0); return res[s.size() - 1][p.size() - 1]; &#125; void match(int i, int j) &#123; if (i &gt;= s.size() || j &gt;= p.size()) return; if (calculated[i][j]) return; res[i][j] = calculated[i][j] = true; if (j &lt; p.size() - 1) &#123; // regexp remained bool starMatch = false; if (j &lt; p.size() - 2 &amp;&amp; p[j + 2] == '*') starMatch = true; if (i &lt; s.size() - 1) &#123; char toMatch = p[j + 1]; bool anyMatch = toMatch == '.'; if (starMatch) &#123; int k = i; while (k &lt; s.size()) &#123; match(k, j + 2); if (k &lt; s.size() - 1 &amp;&amp; (anyMatch || s[k + 1] == toMatch)) k++; else break; &#125; &#125; else &#123; if (anyMatch || s[i + 1] == toMatch) match(i + 1, j + 1); &#125; &#125; else &#123; if (starMatch) match(i, j + 2); &#125; &#125; &#125;private: string s, p; vector&lt;vector&lt;bool&gt;&gt; res, calculated;&#125;;","categories":[],"tags":[{"name":"LeetCode","slug":"LeetCode","permalink":"http://yoursite.com/tags/LeetCode/"}]},{"title":"LeetCode 刷题记录 （一）","slug":"LeetCode-刷题记录-（一）","date":"2017-09-08T07:20:41.000Z","updated":"2017-09-13T09:08:05.541Z","comments":true,"path":"2017/09/08/LeetCode-刷题记录-（一）/","link":"","permalink":"http://yoursite.com/2017/09/08/LeetCode-刷题记录-（一）/","excerpt":"","text":"merge-k-sorted-lists https://leetcode.com/problems/merge-k-sorted-lists/description/ 题意 Merge k sorted linked lists and return it as one sorted list. Analyze and describe its complexity. 给定k个已排序（升序）的链表，将他们合成为一个大的已排序链表。 解题思路 当k=2时就是一个典型的Merge Sort的情况，在这时就只需要每次比较两个待归并链表的首项并把较小的那一项加到新的已排序链表的尾部即可。 扩展到k路归并的话，思路同样是取k个待归并列表的首项并将最小的一项加到结果链表的尾部。对于比较k个首项的大小并获得最小项的过程，我们可以维护一个由所有链表头组成的最小堆（直接用algorithm库的make_heap push_heap pop_heap 完成，省去自己实现），这样每次得到最小项所需的复杂度为O(1) ，添加删除堆节点的复杂度为O(logK) 。最终的复杂度为O(NlogK)，其中N为k个链表的总节点数。 坑点 会给空链表，即输入的vector中会有NULL项。 代码 1234567891011121314151617181920212223242526272829303132333435/** * Definition for singly-linked list. * struct ListNode &#123; * int val; * ListNode *next; * ListNode(int x) : val(x), next(NULL) &#123;&#125; * &#125;; */#include &lt;algorithm&gt;class Solution &#123;public: ListNode* mergeKLists(vector&lt;ListNode*&gt;&amp; lists) &#123; auto head = new ListNode(0), tail = head; vector&lt;ListNode*&gt; heap; for (auto it = lists.begin(); it != lists.end(); it++) &#123; auto node = *it; if (node) heap.push_back(node); &#125; auto comp = [](ListNode* a, ListNode* b) &#123; return a-&gt;val &gt; b-&gt;val; &#125;; make_heap(heap.begin(), heap.end(), comp); while (heap.size()) &#123; pop_heap(heap.begin(), heap.end(), comp); ListNode* selected = heap.back(); heap.pop_back(); tail = tail-&gt;next = new ListNode(selected-&gt;val); if (selected-&gt;next) &#123; heap.push_back(selected-&gt;next); push_heap(heap.begin(), heap.end(), comp); &#125; &#125; return head-&gt;next; &#125;&#125;;","categories":[],"tags":[{"name":"LeetCode","slug":"LeetCode","permalink":"http://yoursite.com/tags/LeetCode/"}]},{"title":"Hello Blog","slug":"Hello-Blog","date":"2017-09-07T04:03:05.000Z","updated":"2017-09-07T13:10:47.297Z","comments":true,"path":"2017/09/07/Hello-Blog/","link":"","permalink":"http://yoursite.com/2017/09/07/Hello-Blog/","excerpt":"","text":"作为一个新搭的Blog，总得写点什么在开头。 怎么又新搭了一个blog？ 其实在这背后，有一个十分悲伤的故事。 其实早在几个月前我就已经用Vue.js手写了一个SPA版的blog放在GitHub Page上了，采用的是和Hexo类似的生成器-静态网页的架构。放在GitHub Page上的只是编译后的静态网页文件，而核心的生成器部分只放在了本地的仓库里，而这个仓库在重装系统时以“反正都在GitHub上有，删了就删了吧“这样的智障思路非常爽快地删掉了。 是不是很悲伤。 总之 我那个可怜的SPA Blog已经消散在硬盘里了（反正写得也很简陋），在可以预见的未来里也没有从零开始搭一个blog的时间，就这样呗。 写点什么？ 想写什么写什么。学习笔记也好，自己写的教程也好，开发时的入坑出坑历程也好都做个记录。 以后不会忘记都做过些什么。","categories":[],"tags":[{"name":"乱讲","slug":"乱讲","permalink":"http://yoursite.com/tags/乱讲/"}]}]}