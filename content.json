{"meta":{"title":"Megrez","subtitle":"Everything is for DOPAMINE","description":"Everything is for DOPAMINE","author":"Zhu Chu","url":"http://yoursite.com"},"pages":[{"title":"tags","date":"2017-09-07T05:12:01.000Z","updated":"2017-09-07T05:13:11.482Z","comments":true,"path":"tags/index.html","permalink":"http://yoursite.com/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"LeetCode-刷题记录（三）","slug":"LeetCode-刷题记录-（三）","date":"2017-09-20T02:53:18.000Z","updated":"2017-09-20T03:23:52.351Z","comments":true,"path":"2017/09/20/LeetCode-刷题记录-（三）/","link":"","permalink":"http://yoursite.com/2017/09/20/LeetCode-刷题记录-（三）/","excerpt":"","text":"Interleaving String https://leetcode.com/problems/interleaving-string/description/ 题意给定三个字符串s1、s2、s3，判断s3是否是由s1与s2交错构成。 比如&quot;abc&quot;就是由&quot;ac&quot;与&quot;b&quot;交错构成的，而&quot;cab&quot;不是。 思路用类似动态规划的思路，dp[i][j]表示是否存在一个交错方式使得s1的前i位与s2的前j位交错能够生成s3的前i+j位。 于是有这样的状态关系：dp[i][j] = (dp[i-1][j] &amp;&amp; s1[i] == s3[i+j]) || (dp[i][j-1] &amp;&amp; d2[j] == s3[i+j])。 实现一下递推就好了，一般可以用记忆化或者类似BFS的递推形式，下面我用的是后一种方法。 代码123456789101112131415161718192021222324252627282930313233class Solution &#123;public: bool isInterleave(string s1, string s2, string s3) &#123; if (s1.size() + s2.size() != s3.size()) return false; vector&lt;vector&lt;bool&gt;&gt; dp; dp.resize(s1.size() + 1); for (auto it = dp.begin(); it != dp.end(); it++) it-&gt;resize(s2.size() + 1, false); dp[0][0] = true; list&lt;pair&lt;int, int&gt;&gt; li = &#123; &#123;0, 0&#125; &#125;; while (!li.empty()) &#123; auto p = li.front(); li.pop_front(); dp[p.first][p.second] = true; if (p.first + p.second + 1 &gt; s3.size()) continue; char next = s3[p.first + p.second]; if (p.first &lt; s1.size() &amp;&amp; s1[p.first] == next) &#123; if (!dp[p.first + 1][p.second]) &#123; dp[p.first + 1][p.second] = true; li.push_back(&#123; p.first + 1, p.second &#125;); &#125; &#125; if (p.second &lt; s2.size() &amp;&amp; s2[p.second] == next) &#123; if (!dp[p.first][p.second + 1]) &#123; dp[p.first][p.second + 1] = true; li.push_back(&#123; p.first, p.second + 1 &#125;); &#125; &#125; &#125; return dp[s1.size()][s2.size()]; &#125;&#125;;","categories":[],"tags":[{"name":"LeetCode","slug":"LeetCode","permalink":"http://yoursite.com/tags/LeetCode/"}]},{"title":"LeetCode 刷题记录 （二）","slug":"LeetCode-刷题记录-（二）","date":"2017-09-12T07:40:04.000Z","updated":"2017-09-13T09:12:08.389Z","comments":true,"path":"2017/09/12/LeetCode-刷题记录-（二）/","link":"","permalink":"http://yoursite.com/2017/09/12/LeetCode-刷题记录-（二）/","excerpt":"","text":"Regular Expression Matching https://leetcode.com/problems/regular-expression-matching/description/ 题意给定一个正则表达式，和一个字符串，判断给定的正则表达式是否与给定的字符串匹配。 这里的正则表达式是简化版的，只有. 与*两种元字符，而且只要求判断是否整体匹配（即整个字符串都是匹配的），所以比实现一个完整的字符串简单多了。 非常暴力的做法直接上带正则表达式支持的语言就好（逃 比如JavaScript： 123456/** * @param &#123;string&#125; s * @param &#123;string&#125; p * @return &#123;boolean&#125; */const isMatch = (s, p) =&gt; !!s.match(new RegExp(`^$&#123;p&#125;$`)); 完事。 没那么暴力的做法解题思路记待匹配串为s，正则表达式串为p，n为s的长度，m为p的长度。 记n、m分别为待匹配串与正则表达式串的长度， 并级。 以类似动态规划的思路，以f[i][j]表示字符串匹配到第i位、正则串匹配到第j位的可行性（那么最终的匹配结果就是f[n][m]）。因此一共有mn个状态。在最坏情况下，需要把所有状态的结果都计算出来，因此时间复杂度为O(mn)。 状态的转移相对比较简单： 对于最简单的字符匹配，有f[i + 1][j + 1] = f[i][j]（s[i + 1] == p[j + 1]时） 对于.*与c*的匹配，有f[i + k][j + 2] = f[i][j]（其中k = 0, 1, ...，需满足s[i + 1] == s[i + 2] == ... == s[i + k] = c 或 c == &#39;.&#39; 。其中c为被* 修饰的待匹配字符） 具体实现见后面的代码。 坑点边界条件比较复杂。 代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152class Solution &#123;public: bool isMatch(string ss, string pp) &#123; s = ' ' + ss; p = ' ' + pp; res.resize(s.size()); calculated.resize(s.size()); for (int i = 0; i &lt; s.size(); i++) &#123; // 初始化 res[i].clear(); res[i].resize(p.size(), false); calculated[i].clear(); calculated[i].resize(p.size(), false); &#125; match(0, 0); return res[s.size() - 1][p.size() - 1]; &#125; void match(int i, int j) &#123; if (i &gt;= s.size() || j &gt;= p.size()) return; if (calculated[i][j]) return; res[i][j] = calculated[i][j] = true; if (j &lt; p.size() - 1) &#123; // regexp remained bool starMatch = false; if (j &lt; p.size() - 2 &amp;&amp; p[j + 2] == '*') starMatch = true; if (i &lt; s.size() - 1) &#123; char toMatch = p[j + 1]; bool anyMatch = toMatch == '.'; if (starMatch) &#123; int k = i; while (k &lt; s.size()) &#123; match(k, j + 2); if (k &lt; s.size() - 1 &amp;&amp; (anyMatch || s[k + 1] == toMatch)) k++; else break; &#125; &#125; else &#123; if (anyMatch || s[i + 1] == toMatch) match(i + 1, j + 1); &#125; &#125; else &#123; if (starMatch) match(i, j + 2); &#125; &#125; &#125;private: string s, p; vector&lt;vector&lt;bool&gt;&gt; res, calculated;&#125;;","categories":[],"tags":[{"name":"LeetCode","slug":"LeetCode","permalink":"http://yoursite.com/tags/LeetCode/"}]},{"title":"LeetCode 刷题记录 （一）","slug":"LeetCode-刷题记录-（一）","date":"2017-09-08T07:20:41.000Z","updated":"2017-09-13T09:08:05.541Z","comments":true,"path":"2017/09/08/LeetCode-刷题记录-（一）/","link":"","permalink":"http://yoursite.com/2017/09/08/LeetCode-刷题记录-（一）/","excerpt":"","text":"merge-k-sorted-lists https://leetcode.com/problems/merge-k-sorted-lists/description/ 题意 Merge k sorted linked lists and return it as one sorted list. Analyze and describe its complexity. 给定k个已排序（升序）的链表，将他们合成为一个大的已排序链表。 解题思路当k=2时就是一个典型的Merge Sort的情况，在这时就只需要每次比较两个待归并链表的首项并把较小的那一项加到新的已排序链表的尾部即可。 扩展到k路归并的话，思路同样是取k个待归并列表的首项并将最小的一项加到结果链表的尾部。对于比较k个首项的大小并获得最小项的过程，我们可以维护一个由所有链表头组成的最小堆（直接用algorithm库的make_heap push_heap pop_heap 完成，省去自己实现），这样每次得到最小项所需的复杂度为O(1) ，添加删除堆节点的复杂度为O(logK) 。最终的复杂度为O(NlogK)，其中N为k个链表的总节点数。 坑点会给空链表，即输入的vector中会有NULL项。 代码1234567891011121314151617181920212223242526272829303132333435/** * Definition for singly-linked list. * struct ListNode &#123; * int val; * ListNode *next; * ListNode(int x) : val(x), next(NULL) &#123;&#125; * &#125;; */#include &lt;algorithm&gt;class Solution &#123;public: ListNode* mergeKLists(vector&lt;ListNode*&gt;&amp; lists) &#123; auto head = new ListNode(0), tail = head; vector&lt;ListNode*&gt; heap; for (auto it = lists.begin(); it != lists.end(); it++) &#123; auto node = *it; if (node) heap.push_back(node); &#125; auto comp = [](ListNode* a, ListNode* b) &#123; return a-&gt;val &gt; b-&gt;val; &#125;; make_heap(heap.begin(), heap.end(), comp); while (heap.size()) &#123; pop_heap(heap.begin(), heap.end(), comp); ListNode* selected = heap.back(); heap.pop_back(); tail = tail-&gt;next = new ListNode(selected-&gt;val); if (selected-&gt;next) &#123; heap.push_back(selected-&gt;next); push_heap(heap.begin(), heap.end(), comp); &#125; &#125; return head-&gt;next; &#125;&#125;;","categories":[],"tags":[{"name":"LeetCode","slug":"LeetCode","permalink":"http://yoursite.com/tags/LeetCode/"}]},{"title":"Hello Blog","slug":"Hello-Blog","date":"2017-09-07T04:03:05.000Z","updated":"2017-09-07T13:10:47.297Z","comments":true,"path":"2017/09/07/Hello-Blog/","link":"","permalink":"http://yoursite.com/2017/09/07/Hello-Blog/","excerpt":"","text":"作为一个新搭的Blog，总得写点什么在开头。 怎么又新搭了一个blog？其实在这背后，有一个十分悲伤的故事。 其实早在几个月前我就已经用Vue.js手写了一个SPA版的blog放在GitHub Page上了，采用的是和Hexo类似的生成器-静态网页的架构。放在GitHub Page上的只是编译后的静态网页文件，而核心的生成器部分只放在了本地的仓库里，而这个仓库在重装系统时以“反正都在GitHub上有，删了就删了吧“这样的智障思路非常爽快地删掉了。 是不是很悲伤。 总之我那个可怜的SPA Blog已经消散在硬盘里了（反正写得也很简陋），在可以预见的未来里也没有从零开始搭一个blog的时间，就这样呗。 写点什么？想写什么写什么。学习笔记也好，自己写的教程也好，开发时的入坑出坑历程也好都做个记录。 以后不会忘记都做过些什么。","categories":[],"tags":[{"name":"乱讲","slug":"乱讲","permalink":"http://yoursite.com/tags/乱讲/"}]}]}