{"meta":{"title":"Megrez","subtitle":"Everything is for DOPAMINE","description":"Everything is for DOPAMINE","author":"Zhu Chu","url":"http://yoursite.com"},"pages":[{"title":"tags","date":"2017-09-07T05:12:01.000Z","updated":"2017-09-07T05:13:11.482Z","comments":true,"path":"tags/index.html","permalink":"http://yoursite.com/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"LeetCode 刷题记录 （七）","slug":"LeetCode-刷题记录-（七）","date":"2017-10-18T12:57:18.000Z","updated":"2017-10-18T13:31:02.485Z","comments":true,"path":"2017/10/18/LeetCode-刷题记录-（七）/","link":"","permalink":"http://yoursite.com/2017/10/18/LeetCode-刷题记录-（七）/","excerpt":"","text":"Binary Tree Maximum Path Sum https://leetcode.com/problems/binary-tree-maximum-path-sum/description/ 题意 给定一棵二叉树，二叉树上每个节点有一个整数权值。求在这棵二叉树上经过的节点的权值和最长的路径的权值和大小（路径至少经过一个节点）。 思路 对于一棵二叉树，上面的所有路径其实可以分为以下几种： 只经过左子树中的节点 只经过右子树中的节点 只经过左子树中的节点和根 只经过右子树中的节点和根 左右子树节点和根都经过 很显然，第五种路径其实是第三、四种路径和根节点的组合；另外几种路径也和对应的子树的子树的某几种路径相关。 于是就可以递归计算，对每个节点分别计算在相应子树中五种路径的最大权值和即可。 代码 LeetCode直接提供了TreeNode的定义： 123456789/*** Definition for a binary tree node.* struct TreeNode &#123;* int val;* TreeNode *left;* TreeNode *right;* TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;* &#125;;*/ 但上面挂载的信息还太少，又不能修改这个定义，于是只能新创建一个结构SolNode，添加一些成员，通过TreeNode进行构造。 因为SolNode在构造的时候会递归地对左右子树进行构造，正好和解题的顺序一样，所以干脆把解题过程也写在SolNode的构造函数里了。 1234567891011121314151617181920212223242526272829303132struct SolNode &#123; int val, leftMax, rightMax, midMax, ansMax; bool allNeg; int maxVal; SolNode *left, *right; SolNode(TreeNode *node) &#123; if (!node) &#123; ansMax = midMax = leftMax = rightMax = 0; allNeg = true; maxVal = -2e9; return; &#125; left = new SolNode(node-&gt;left); right = new SolNode(node-&gt;right); val = node-&gt;val; leftMax = val + max(max(left-&gt;leftMax, left-&gt;rightMax), 0); rightMax = val + max(max(right-&gt;leftMax, right-&gt;rightMax), 0); midMax = leftMax + rightMax - val; int t1 = max(left-&gt;ansMax, right-&gt;ansMax); int t2 = max(leftMax, rightMax); ansMax = max(max(t1, t2), midMax); maxVal = max(max(left-&gt;maxVal, right-&gt;maxVal), val); allNeg = left-&gt;allNeg &amp;&amp; right-&gt;allNeg &amp;&amp; val &lt; 0; &#125;&#125;;class Solution &#123;public: int maxPathSum(TreeNode* root) &#123; auto solNode = new SolNode(root); return solNode-&gt;allNeg ? solNode-&gt;maxVal : solNode-&gt;ansMax; &#125;&#125;; Minimum Window Substring https://leetcode.com/problems/minimum-window-substring/description/ 题意 给定两个字符串\\(S\\)和\\(T\\)（题目没说，假设由ascii从0-255的字符都有可能出现），求\\(S\\)的最短子串\\(S&#39;\\)，使得\\(T\\)中的每个字符在\\(S&#39;\\)中都出现。 Node: 如果字符\\(c\\)在\\(T\\)中出现多次，那么\\(c\\)在\\(S&#39;\\)中也应出现至少相同次数。 输入保证这样的最短子串是唯一的。 思路 其实题目标题中的Window就充满了暗示…… 用两个迭代器\\(i\\)与\\(pos\\)分别为指向满足要求的子串的头与尾（以下标0方向为尾）。 在初始时\\(pos=0\\)，\\(i\\)不断增大直到\\(S[0:i]\\)满足要求为止，此时\\(S[0:i]\\)是一个满足要求的子串（不一定最短）。然后\\(i\\)每次右移一位，记\\(i^{&#39;}=i+1\\)，此时得到的新子串\\(S[0:i^{&#39;}]\\)也必定满足要求，但由于这个子串的左端可能会有多余的、删掉也不妨碍子串满足要求的字符，于是一直右移\\(pos\\)直到没有多余字符为止。 具体实现见下面代码。 代码 12345678910111213141516171819202122232425262728293031class Solution &#123; int req[256], meet[256];public: string minWindow(string s, string t) &#123; if (s.length() &lt; t.length()) return \"\"; memset(req, 0, 256); memset(meet, 0, 256); int unMeet = 0; for (char c : t) &#123; if (!req[c]) unMeet++; req[c]++; &#125; int minLen = 2e9, minPos; bool ok = false; for (int i = 0, pos = 0; i &lt; s.length(); i++) &#123; meet[s[i]]++; if (meet[s[i]] == req[s[i]]) &#123; // just meet unMeet--; if (!unMeet) ok = true; &#125; while (meet[s[pos]] &gt; req[s[pos]]) meet[s[pos++]]--; if (ok &amp;&amp; i - pos + 1 &lt; minLen) &#123; minLen = i - pos + 1; minPos = pos; &#125; &#125; return ok ? s.substr(minPos, minLen) : \"\"; &#125;&#125;;","categories":[],"tags":[{"name":"LeetCode","slug":"LeetCode","permalink":"http://yoursite.com/tags/LeetCode/"}]},{"title":"LeetCode 刷题记录 （六）","slug":"LeetCode-刷题记录-（六）","date":"2017-10-13T07:19:51.000Z","updated":"2017-10-14T16:04:45.545Z","comments":true,"path":"2017/10/13/LeetCode-刷题记录-（六）/","link":"","permalink":"http://yoursite.com/2017/10/13/LeetCode-刷题记录-（六）/","excerpt":"","text":"Candy https://leetcode.com/problems/candy/description/ 题意 \\(N\\)个小朋友站成一行，每个小朋友有一个评级\\(R_i\\)。现在要给每个小朋友派发糖果，第\\(i\\)个小朋友得到的糖果的数量\\(C_i\\)须满足如下条件： \\(C_i\\ge1\\) 对于\\(|i-j|=1\\)，如果\\(R_i&gt;R_j\\)，则\\(C_i&gt;C_j\\) 计算最少需要的糖果总数。 思路 根据要求递归计算即可，加上记忆化防止重复计算。时间复杂度为\\(\\mathcal{O}(N)\\)。 代码 1234567891011121314151617181920212223class Solution &#123; vector&lt;int&gt; res; vector&lt;int&gt; ratings; int calculate(int pos) &#123; if (pos &lt; 0 || pos &gt;= res.size()) return 0; if (res[pos] != -1) return res[pos]; int left = get(pos - 1) &lt; get(pos) ? calculate(pos - 1) : 0; int right = get(pos + 1) &lt; get(pos) ? calculate(pos + 1) : 0; return res[pos] = max(left, right) + 1; &#125; int get(int pos) &#123; return (pos &lt; 0 || pos &gt;= ratings.size()) ? 1e9 : ratings[pos]; &#125;public: int candy(vector&lt;int&gt;&amp; ratings) &#123; this-&gt;ratings = ratings; res.clear(); res.resize(ratings.size(), -1); int ans = 0; for (int i = 0; i &lt; res.size(); i++) ans += calculate(i); return ans; &#125;&#125;; Maximum Subarray https://leetcode.com/problems/maximum-subarray/description/ 题意 给定一个数组\\(A\\)，求它的最大子段和。 思路 经典的DP题。 \\(F_i\\)表示以\\(A_i\\)结尾的所有子段中能够得到的最大字段和，于是有： \\[ F_i=\\max\\{F_{i-1},0\\}+A_i \\] 初始有\\(F_0=A_0\\)。 时间复杂度为\\(\\mathcal{O}(N)\\)，\\(N\\)为数组中元素个数。 代码 1234567891011121314class Solution &#123;public: int maxSubArray(vector&lt;int&gt;&amp; nums) &#123; vector&lt;int&gt; f; f.resize(nums.size()); f[0] = nums[0]; int ans = f[0]; for (int i = 1; i &lt; nums.size(); i++) &#123; f[i] = max(f[i - 1], 0) + nums[i]; ans = max(ans, f[i]); &#125; return ans; &#125;&#125;; Find Median from Data Stream https://leetcode.com/problems/find-median-from-data-stream/description/ 题意 要求实现一个容器类，能够： 将一个元素加入容器中 计算当前容器中所有元素的中位数 思路 维护两个堆，大根堆\\(H_1\\)和小根堆\\(H_2\\)，\\(H_1\\)里面是当前容器中最小的\\(\\lfloor\\frac{N+1}{2}\\rfloor\\)个元素，相应的\\(H_2\\)里面是当前容器中最大的\\(N-\\lfloor\\frac{N+1}{2}\\rfloor\\)个元素。在有新元素加入时处理一下新元素和两个堆的根元素之间的移动关系即可，具体处理逻辑见下面代码。 在\\(N\\)为奇数时，中位数就是\\(H_1\\)的根；否则中位数是两个堆的根的均值。 时间复杂度：添加元素\\(\\mathcal{O}(\\log N)\\)，计算当前中位数\\(\\mathcal{O}(1)\\)。 代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748class MedianFinder &#123; vector&lt;int&gt; left, right; int size;public: /** initialize your data structure here. */ MedianFinder() &#123; size = 0; &#125; void addNum(int num) &#123; size++; int leftCap = (size + 1) / 2, rightCap = size - leftCap; if (left.size() &lt; leftCap) &#123; int toLeft; if (right.size() == 0 || num &lt;= right.front()) &#123; toLeft = num; &#125; else &#123; toLeft = right.front(); pop_heap(right.begin(), right.end(), greater&lt;int&gt;()); right.pop_back(); right.push_back(num); push_heap(right.begin(), right.end(), greater&lt;int&gt;()); &#125; left.push_back(toLeft); push_heap(left.begin(), left.end()); &#125; else &#123; int toRight; if (left.size() == 0 || num &gt;= left.front()) &#123; toRight = num; &#125; else &#123; toRight = left.front(); pop_heap(left.begin(), left.end()); left.pop_back(); left.push_back(num); push_heap(left.begin(), left.end()); &#125; right.push_back(toRight); push_heap(right.begin(), right.end(), greater&lt;int&gt;()); &#125; &#125; double findMedian() const &#123; if (size % 2) return left.front(); else return (left.front() + right.front()) / 2.0; &#125;&#125;;","categories":[],"tags":[{"name":"LeetCode","slug":"LeetCode","permalink":"http://yoursite.com/tags/LeetCode/"}]},{"title":"在Hexo中使用数学公式","slug":"在Hexo中使用数学公式","date":"2017-10-12T04:17:15.000Z","updated":"2017-10-12T05:11:33.803Z","comments":true,"path":"2017/10/12/在Hexo中使用数学公式/","link":"","permalink":"http://yoursite.com/2017/10/12/在Hexo中使用数学公式/","excerpt":"","text":"之前在写LeetCode解题报告的时候总是不可避免地要通过一些比较数学的方式来描述题解，原本认为Hexo自带的Markdown Renderer不支持公式渲染于是就用代码块将就了。后来越写越不能忍受，才下定决定一定要把公式功能加上。 \\(A_{i,j}\\)比A[i][j]酷多了啊！ 在查解决方案的时候发现很幸运地，现在我在用的主题Next其实已经集成了MathJax，只需要在themes/next/_config.yml里面把对应设置项打开就行了： 12345# MathJax Supportmathjax: enable: true per_page: false cdn: //cdn.bootcss.com/mathjax/2.7.1/latest.js?config=TeX-AMS-MML_HTMLorMML 刷新之后发现的确已经能显示数学公式了，但在需要用到下标的时候（例如打算使用$A_i$得到\\(A_i\\)），里面的下划线会和Markdown语法中的_斜体_语法冲突，也就是说，一旦有$A_i$一些其他的文本$B_i$这样的情况出现，里面的两个_会匹配成为Markdown的斜体标记，公式就渲染出错了。 一个Naive的解决方案就是在每一个下划线前面加转义符，也就是用\\_替代_，这样能防止被解析成斜体 但这实在是太麻烦了，谁想每次在写公式下标的时候都加个斜杠呢。 后来找到了一个几乎完美的解决方案：修改Hexo渲染Markdown时用的渲染引擎！ 在package.json里能看到Hexo原本用的是hexo-renderer-marked，把它换成hexo-renderer-pandoc即可。 Pandoc是一个十分强大的开源格式转换工具。 hexo-renderer-pandoc通过调用系统中的Pandoc来渲染Markdown，因此需要先在系统中安装Pandoc才能正常使用 12npm rm hexo-renderer-markednpm i hexo-renderer-pandoc 完美解决公式渲染问题，能在博客里面爽用MathJax写公式了（唯一的缺点是需要额外安装Pandoc，不能直接npm i解决所有依赖问题，但这又何妨呢）。","categories":[],"tags":[{"name":"乱讲","slug":"乱讲","permalink":"http://yoursite.com/tags/乱讲/"},{"name":"Hexo","slug":"Hexo","permalink":"http://yoursite.com/tags/Hexo/"}]},{"title":"LeetCode 刷题记录 （五）","slug":"LeetCode-刷题记录-（五）","date":"2017-10-11T06:38:47.000Z","updated":"2017-10-13T05:46:28.785Z","comments":true,"path":"2017/10/11/LeetCode-刷题记录-（五）/","link":"","permalink":"http://yoursite.com/2017/10/11/LeetCode-刷题记录-（五）/","excerpt":"","text":"Dungeon Game https://leetcode.com/problems/dungeon-game/description/ 题意 一个\\(m\\times n\\)的矩阵当中，一个骑士从左上角走到右下角，只能向右或向下移动。骑士有初始血量\\(H\\)，矩阵的每一格中有一个数值\\(A_{i,j}\\)表示移动到这一格时对血量的增减，计算能保证不在任意时刻血量降至0以下的最小初始血量\\(H_{min}\\)。 思路 因为只能向右或下移动，因此避免了走回路的情况。记\\(F_{i,j}\\)为走到以第\\(i\\)行第\\(j\\)列（从0开始）为起点，走到终点要求的最小初始血量。显然地，\\(F_{i,j}\\)只与\\(F_{i,j+1}\\)、\\(F_{i+1,j}\\)以及\\(A_{i,j}\\)相关。于是有下面的关系： \\[ F_{i,j}=max\\{0,-A_{i,j}+min\\{F_{i,j+1},F_{i+1,j}\\}\\} \\] 特别地，对于终点有： \\[ F_{m-1,n-1}=max\\{0, -A_{m-1,n-1}\\} \\] 上面的递推保证了在任意时刻血量均不会降为负数，因为题目里需要正数血量，因此最后的答案就是\\(F_{0,0}+1\\)。 代码 123456789101112131415161718class Solution &#123;public: int calculateMinimumHP(vector&lt;vector&lt;int&gt;&gt;&amp; dungeon) &#123; int n = dungeon.size(), m = dungeon.front().size(); vector&lt;vector&lt;int&gt;&gt; res; res.resize(n + 1); for (auto it = res.begin(); it != res.end(); it++) it-&gt;resize(m + 1, 1e9); res[n - 1][m - 1] = max(-dungeon[n - 1][m - 1], 0); for (int i = n - 1; i &gt;= 0; i--) &#123; for (int j = m - 1; j &gt;= 0; j--) &#123; if (i == n - 1 &amp;&amp; j == m - 1) continue; res[i][j] = -dungeon[i][j] + min(res[i][j + 1], res[i + 1][j]); res[i][j] = max(res[i][j], 0); &#125; &#125; return res[0][0] + 1; &#125;&#125;; Shortest Palindrome https://leetcode.com/problems/shortest-palindrome/description/ 题意 给定一个字符串\\(S\\)，在它前面增加若干字符得到\\(S&#39;\\)使得它成为一个回文字符串，求满足要求的最短的\\(S&#39;\\)。 思路 如果能将\\(S\\)分解为\\(S_1S_2\\)，其中\\(S_1\\)为回文串，那么只需要在\\(S_1S_2\\)前加上\\(S_2\\)的翻转\\(S&#39;_2\\)，得到的\\(S&#39;_2S_1S_2\\)就是一个回文字符串。 问题变为寻找一个最长的回文子串\\(S_1\\)。 这是一个经典的问题，可以使用Manacher算法解决。 代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748class Solution &#123; static string preprocess(const string&amp; s) &#123; string res; res.resize(s.size() * 2 + 1); for (int i = 0; i &lt; res.size(); i++) &#123; if (i % 2) res[i] = s[i / 2]; else res[i] = '#'; &#125; return res; &#125; static int mirror(int pos, int middle) &#123; return 2 * middle - pos; &#125; static int longestPrefixingPalidrome(const string&amp; s) &#123; string ss = preprocess(s); vector&lt;int&gt; rl = &#123; 0 &#125;; int maxRight = 0, pos = 0, ans = 0; for (int i = 1; i &lt; ss.length(); i++) &#123; int j; if (i &gt; maxRight) j = i; else &#123; // i &lt;= maxRight int knownLen = rl[mirror(i, pos)]; j = min(i + knownLen, maxRight); &#125; while (j &lt; ss.length() &amp;&amp; mirror(j, i) &gt;= 0 &amp;&amp; ss[j] == ss[mirror(j, i)]) j++; j--; rl.push_back(j - i); if (j &gt; maxRight) &#123; maxRight = j; pos = i; &#125; if (mirror(j, i) == 0) ans = max(ans, rl[i]); &#125; return ans; &#125;public: string shortestPalindrome(string s) &#123; int len = longestPrefixingPalidrome(s); auto left = s.substr(len); reverse(left.begin(), left.end()); return left + s; &#125;&#125;;","categories":[],"tags":[{"name":"LeetCode","slug":"LeetCode","permalink":"http://yoursite.com/tags/LeetCode/"}]},{"title":"LeetCode 刷题记录 （四）","slug":"LeetCode-刷题记录-（四）","date":"2017-09-27T06:30:54.000Z","updated":"2017-09-27T07:06:44.818Z","comments":true,"path":"2017/09/27/LeetCode-刷题记录-（四）/","link":"","permalink":"http://yoursite.com/2017/09/27/LeetCode-刷题记录-（四）/","excerpt":"","text":"Sliding Window Maximum https://leetcode.com/problems/sliding-window-maximum/description/ 题意 一个有n个数字的数组a，对于给定的k，对每一组连续的k个数组元素（即a[i...i+k-1] ），输出这k个元素中的最大值。 思路 注意到对于a[i]，如果存在j &gt; i使得a[j] &gt;= a[i]，那么对于所有末端位置大于等于j的k元组，a[i]都不可能会是这个k元组中的最大值，基于只可能出现以下几种情况： a[i]不在这个k元组中，此时a[i]自然不可能是这个k元组的最值； a[i]在这个k元组中，但因该k元组末端位置在j右侧，即a[j]也在k元组中，a[i]被a[j] 淘汰； 因此可以枚举k元组的右侧端点t，同时维护一个队列：每当t右移，则将a[t]加入队列尾，在加入前淘汰（移除）所有在队列中的不大于a[t]的元素。经过这一过程后的队列头就是以t为右侧端点的k元组的最大值。 代码 1234567891011121314151617class Solution &#123;public: vector&lt;int&gt; maxSlidingWindow(vector&lt;int&gt;&amp; nums, int k) &#123; list&lt;pair&lt;int, int&gt;&gt; q; vector&lt;int&gt; res; for (int i = 0; i &lt; nums.size(); i++) &#123; while (!q.empty() &amp;&amp; q.front().second &lt; i - k + 1) q.pop_front(); while (!q.empty() &amp;&amp; q.back().first &lt; nums[i]) q.pop_back(); q.push_back(&#123; nums[i], i &#125;); if (i &gt;= k - 1) res.push_back(q.front().first); &#125; return res; &#125;&#125;; Binary Tree Postorder Traversal https://leetcode.com/problems/binary-tree-postorder-traversal/description/ 题意 给定一个二叉树，以后序遍历方式输出所有的节点。（这题居然也是Hard） 代码 12345678910111213141516171819202122232425/** * Definition for a binary tree node. * struct TreeNode &#123; * int val; * TreeNode *left; * TreeNode *right; * TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125; * &#125;; */class Solution &#123; vector&lt;int&gt; res;public: vector&lt;int&gt; postorderTraversal(TreeNode* root) &#123; res.clear(); traverse(root); return res; &#125; void traverse(TreeNode* root) &#123; if (!root) return; traverse(root-&gt;left); traverse(root-&gt;right); res.push_back(root-&gt;val); &#125;&#125;;","categories":[],"tags":[{"name":"LeetCode","slug":"LeetCode","permalink":"http://yoursite.com/tags/LeetCode/"}]},{"title":"LeetCode-刷题记录（三）","slug":"LeetCode-刷题记录-（三）","date":"2017-09-20T02:53:18.000Z","updated":"2017-09-20T03:23:52.351Z","comments":true,"path":"2017/09/20/LeetCode-刷题记录-（三）/","link":"","permalink":"http://yoursite.com/2017/09/20/LeetCode-刷题记录-（三）/","excerpt":"","text":"Interleaving String https://leetcode.com/problems/interleaving-string/description/ 题意 给定三个字符串s1、s2、s3，判断s3是否是由s1与s2交错构成。 比如&quot;abc&quot;就是由&quot;ac&quot;与&quot;b&quot;交错构成的，而&quot;cab&quot;不是。 思路 用类似动态规划的思路，dp[i][j]表示是否存在一个交错方式使得s1的前i位与s2的前j位交错能够生成s3的前i+j位。 于是有这样的状态关系：dp[i][j] = (dp[i-1][j] &amp;&amp; s1[i] == s3[i+j]) || (dp[i][j-1] &amp;&amp; d2[j] == s3[i+j])。 实现一下递推就好了，一般可以用记忆化或者类似BFS的递推形式，下面我用的是后一种方法。 代码 123456789101112131415161718192021222324252627282930313233class Solution &#123;public: bool isInterleave(string s1, string s2, string s3) &#123; if (s1.size() + s2.size() != s3.size()) return false; vector&lt;vector&lt;bool&gt;&gt; dp; dp.resize(s1.size() + 1); for (auto it = dp.begin(); it != dp.end(); it++) it-&gt;resize(s2.size() + 1, false); dp[0][0] = true; list&lt;pair&lt;int, int&gt;&gt; li = &#123; &#123;0, 0&#125; &#125;; while (!li.empty()) &#123; auto p = li.front(); li.pop_front(); dp[p.first][p.second] = true; if (p.first + p.second + 1 &gt; s3.size()) continue; char next = s3[p.first + p.second]; if (p.first &lt; s1.size() &amp;&amp; s1[p.first] == next) &#123; if (!dp[p.first + 1][p.second]) &#123; dp[p.first + 1][p.second] = true; li.push_back(&#123; p.first + 1, p.second &#125;); &#125; &#125; if (p.second &lt; s2.size() &amp;&amp; s2[p.second] == next) &#123; if (!dp[p.first][p.second + 1]) &#123; dp[p.first][p.second + 1] = true; li.push_back(&#123; p.first, p.second + 1 &#125;); &#125; &#125; &#125; return dp[s1.size()][s2.size()]; &#125;&#125;;","categories":[],"tags":[{"name":"LeetCode","slug":"LeetCode","permalink":"http://yoursite.com/tags/LeetCode/"}]},{"title":"LeetCode 刷题记录 （二）","slug":"LeetCode-刷题记录-（二）","date":"2017-09-12T07:40:04.000Z","updated":"2017-09-13T09:12:08.389Z","comments":true,"path":"2017/09/12/LeetCode-刷题记录-（二）/","link":"","permalink":"http://yoursite.com/2017/09/12/LeetCode-刷题记录-（二）/","excerpt":"","text":"Regular Expression Matching https://leetcode.com/problems/regular-expression-matching/description/ 题意 给定一个正则表达式，和一个字符串，判断给定的正则表达式是否与给定的字符串匹配。 这里的正则表达式是简化版的，只有. 与*两种元字符，而且只要求判断是否整体匹配（即整个字符串都是匹配的），所以比实现一个完整的字符串简单多了。 非常暴力的做法 直接上带正则表达式支持的语言就好（逃 比如JavaScript： 123456/** * @param &#123;string&#125; s * @param &#123;string&#125; p * @return &#123;boolean&#125; */const isMatch = (s, p) =&gt; !!s.match(new RegExp(`^$&#123;p&#125;$`)); 完事。 没那么暴力的做法 解题思路 记待匹配串为s，正则表达式串为p，n为s的长度，m为p的长度。 记n、m分别为待匹配串与正则表达式串的长度， 并级。 以类似动态规划的思路，以f[i][j]表示字符串匹配到第i位、正则串匹配到第j位的可行性（那么最终的匹配结果就是f[n][m]）。因此一共有mn个状态。在最坏情况下，需要把所有状态的结果都计算出来，因此时间复杂度为O(mn)。 状态的转移相对比较简单： 对于最简单的字符匹配，有f[i + 1][j + 1] = f[i][j]（s[i + 1] == p[j + 1]时） 对于.*与c*的匹配，有f[i + k][j + 2] = f[i][j]（其中k = 0, 1, ...，需满足s[i + 1] == s[i + 2] == ... == s[i + k] = c 或 c == '.' 。其中c为被* 修饰的待匹配字符） 具体实现见后面的代码。 坑点 边界条件比较复杂。 代码 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152class Solution &#123;public: bool isMatch(string ss, string pp) &#123; s = ' ' + ss; p = ' ' + pp; res.resize(s.size()); calculated.resize(s.size()); for (int i = 0; i &lt; s.size(); i++) &#123; // 初始化 res[i].clear(); res[i].resize(p.size(), false); calculated[i].clear(); calculated[i].resize(p.size(), false); &#125; match(0, 0); return res[s.size() - 1][p.size() - 1]; &#125; void match(int i, int j) &#123; if (i &gt;= s.size() || j &gt;= p.size()) return; if (calculated[i][j]) return; res[i][j] = calculated[i][j] = true; if (j &lt; p.size() - 1) &#123; // regexp remained bool starMatch = false; if (j &lt; p.size() - 2 &amp;&amp; p[j + 2] == '*') starMatch = true; if (i &lt; s.size() - 1) &#123; char toMatch = p[j + 1]; bool anyMatch = toMatch == '.'; if (starMatch) &#123; int k = i; while (k &lt; s.size()) &#123; match(k, j + 2); if (k &lt; s.size() - 1 &amp;&amp; (anyMatch || s[k + 1] == toMatch)) k++; else break; &#125; &#125; else &#123; if (anyMatch || s[i + 1] == toMatch) match(i + 1, j + 1); &#125; &#125; else &#123; if (starMatch) match(i, j + 2); &#125; &#125; &#125;private: string s, p; vector&lt;vector&lt;bool&gt;&gt; res, calculated;&#125;;","categories":[],"tags":[{"name":"LeetCode","slug":"LeetCode","permalink":"http://yoursite.com/tags/LeetCode/"}]},{"title":"LeetCode 刷题记录 （一）","slug":"LeetCode-刷题记录-（一）","date":"2017-09-08T07:20:41.000Z","updated":"2017-09-13T09:08:05.541Z","comments":true,"path":"2017/09/08/LeetCode-刷题记录-（一）/","link":"","permalink":"http://yoursite.com/2017/09/08/LeetCode-刷题记录-（一）/","excerpt":"","text":"merge-k-sorted-lists https://leetcode.com/problems/merge-k-sorted-lists/description/ 题意 Merge k sorted linked lists and return it as one sorted list. Analyze and describe its complexity. 给定k个已排序（升序）的链表，将他们合成为一个大的已排序链表。 解题思路 当k=2时就是一个典型的Merge Sort的情况，在这时就只需要每次比较两个待归并链表的首项并把较小的那一项加到新的已排序链表的尾部即可。 扩展到k路归并的话，思路同样是取k个待归并列表的首项并将最小的一项加到结果链表的尾部。对于比较k个首项的大小并获得最小项的过程，我们可以维护一个由所有链表头组成的最小堆（直接用algorithm库的make_heap push_heap pop_heap 完成，省去自己实现），这样每次得到最小项所需的复杂度为O(1) ，添加删除堆节点的复杂度为O(logK) 。最终的复杂度为O(NlogK)，其中N为k个链表的总节点数。 坑点 会给空链表，即输入的vector中会有NULL项。 代码 1234567891011121314151617181920212223242526272829303132333435/** * Definition for singly-linked list. * struct ListNode &#123; * int val; * ListNode *next; * ListNode(int x) : val(x), next(NULL) &#123;&#125; * &#125;; */#include &lt;algorithm&gt;class Solution &#123;public: ListNode* mergeKLists(vector&lt;ListNode*&gt;&amp; lists) &#123; auto head = new ListNode(0), tail = head; vector&lt;ListNode*&gt; heap; for (auto it = lists.begin(); it != lists.end(); it++) &#123; auto node = *it; if (node) heap.push_back(node); &#125; auto comp = [](ListNode* a, ListNode* b) &#123; return a-&gt;val &gt; b-&gt;val; &#125;; make_heap(heap.begin(), heap.end(), comp); while (heap.size()) &#123; pop_heap(heap.begin(), heap.end(), comp); ListNode* selected = heap.back(); heap.pop_back(); tail = tail-&gt;next = new ListNode(selected-&gt;val); if (selected-&gt;next) &#123; heap.push_back(selected-&gt;next); push_heap(heap.begin(), heap.end(), comp); &#125; &#125; return head-&gt;next; &#125;&#125;;","categories":[],"tags":[{"name":"LeetCode","slug":"LeetCode","permalink":"http://yoursite.com/tags/LeetCode/"}]},{"title":"Hello Blog","slug":"Hello-Blog","date":"2017-09-07T04:03:05.000Z","updated":"2017-09-07T13:10:47.297Z","comments":true,"path":"2017/09/07/Hello-Blog/","link":"","permalink":"http://yoursite.com/2017/09/07/Hello-Blog/","excerpt":"","text":"作为一个新搭的Blog，总得写点什么在开头。 怎么又新搭了一个blog？ 其实在这背后，有一个十分悲伤的故事。 其实早在几个月前我就已经用Vue.js手写了一个SPA版的blog放在GitHub Page上了，采用的是和Hexo类似的生成器-静态网页的架构。放在GitHub Page上的只是编译后的静态网页文件，而核心的生成器部分只放在了本地的仓库里，而这个仓库在重装系统时以“反正都在GitHub上有，删了就删了吧“这样的智障思路非常爽快地删掉了。 是不是很悲伤。 总之 我那个可怜的SPA Blog已经消散在硬盘里了（反正写得也很简陋），在可以预见的未来里也没有从零开始搭一个blog的时间，就这样呗。 写点什么？ 想写什么写什么。学习笔记也好，自己写的教程也好，开发时的入坑出坑历程也好都做个记录。 以后不会忘记都做过些什么。","categories":[],"tags":[{"name":"乱讲","slug":"乱讲","permalink":"http://yoursite.com/tags/乱讲/"}]}]}